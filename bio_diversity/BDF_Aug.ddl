-- Generated by Oracle SQL Developer Data Modeler 18.4.0.339.1536
--   at:        2020-09-07 13:44:48 ADT
--   site:      Oracle Database 11g
--   type:      Oracle Database 11g



DROP TABLE anidetailxref CASCADE CONSTRAINTS;

DROP TABLE anidetsubjcode CASCADE CONSTRAINTS;

DROP TABLE animaldetcode CASCADE CONSTRAINTS;

DROP TABLE collection CASCADE CONSTRAINTS;

DROP TABLE containerdetcode CASCADE CONSTRAINTS;

DROP TABLE containerxref CASCADE CONSTRAINTS;

DROP TABLE contdetsubjcode CASCADE CONSTRAINTS;

DROP TABLE count CASCADE CONSTRAINTS;

DROP TABLE countcode CASCADE CONSTRAINTS;

DROP TABLE countdet CASCADE CONSTRAINTS;

DROP TABLE cup CASCADE CONSTRAINTS;

DROP TABLE cupdet CASCADE CONSTRAINTS;

DROP TABLE drawer CASCADE CONSTRAINTS;

DROP TABLE envcode CASCADE CONSTRAINTS;

DROP TABLE envcondfile CASCADE CONSTRAINTS;

DROP TABLE envcondition CASCADE CONSTRAINTS;

DROP TABLE envsubjcode CASCADE CONSTRAINTS;

DROP TABLE envtreatment CASCADE CONSTRAINTS;

DROP TABLE envtreatmentcode CASCADE CONSTRAINTS;

DROP TABLE event CASCADE CONSTRAINTS;

DROP TABLE eventcode CASCADE CONSTRAINTS;

DROP TABLE facilitycode CASCADE CONSTRAINTS;

DROP TABLE fecundity CASCADE CONSTRAINTS;

DROP TABLE feedcode CASCADE CONSTRAINTS;

DROP TABLE feeding CASCADE CONSTRAINTS;

DROP TABLE feedmethod CASCADE CONSTRAINTS;

DROP TABLE "GROUP" CASCADE CONSTRAINTS;

DROP TABLE groupdet CASCADE CONSTRAINTS;

DROP TABLE heathunit CASCADE CONSTRAINTS;

DROP TABLE heathunitdet CASCADE CONSTRAINTS;

DROP TABLE image CASCADE CONSTRAINTS;

DROP TABLE imagecode CASCADE CONSTRAINTS;

DROP TABLE individual CASCADE CONSTRAINTS;

DROP TABLE individualdet CASCADE CONSTRAINTS;

DROP TABLE indtreatcode CASCADE CONSTRAINTS;

DROP TABLE indtreatment CASCADE CONSTRAINTS;

DROP TABLE instdetcode CASCADE CONSTRAINTS;

DROP TABLE instrument CASCADE CONSTRAINTS;

DROP TABLE instrumentcode CASCADE CONSTRAINTS;

DROP TABLE instrumentdet CASCADE CONSTRAINTS;

DROP TABLE location CASCADE CONSTRAINTS;

DROP TABLE loccode CASCADE CONSTRAINTS;

DROP TABLE matingplan CASCADE CONSTRAINTS;

DROP TABLE organization CASCADE CONSTRAINTS;

DROP TABLE pairing CASCADE CONSTRAINTS;

DROP TABLE personnelcode CASCADE CONSTRAINTS;

DROP TABLE prioritycode CASCADE CONSTRAINTS;

DROP TABLE progauthority CASCADE CONSTRAINTS;

DROP TABLE program CASCADE CONSTRAINTS;

DROP TABLE protocode CASCADE CONSTRAINTS;

DROP TABLE protocol CASCADE CONSTRAINTS;

DROP TABLE protofile CASCADE CONSTRAINTS;

DROP TABLE qualcode CASCADE CONSTRAINTS;

DROP TABLE releasesitecode CASCADE CONSTRAINTS;

DROP TABLE rivercode CASCADE CONSTRAINTS;

DROP TABLE rolecode CASCADE CONSTRAINTS;

DROP TABLE sample CASCADE CONSTRAINTS;

DROP TABLE samplecode CASCADE CONSTRAINTS;

DROP TABLE sampledet CASCADE CONSTRAINTS;

DROP TABLE sire CASCADE CONSTRAINTS;

DROP TABLE spawndet CASCADE CONSTRAINTS;

DROP TABLE spawndetcode CASCADE CONSTRAINTS;

DROP TABLE spawndetsubjcode CASCADE CONSTRAINTS;

DROP TABLE spawning CASCADE CONSTRAINTS;

DROP TABLE speciescode CASCADE CONSTRAINTS;

DROP TABLE stockcode CASCADE CONSTRAINTS;

DROP TABLE subrivercode CASCADE CONSTRAINTS;

DROP TABLE tank CASCADE CONSTRAINTS;

DROP TABLE tankdet CASCADE CONSTRAINTS;

DROP TABLE team CASCADE CONSTRAINTS;

DROP TABLE tray CASCADE CONSTRAINTS;

DROP TABLE traydet CASCADE CONSTRAINTS;

DROP TABLE tributary CASCADE CONSTRAINTS;

DROP TABLE trough CASCADE CONSTRAINTS;

DROP TABLE troughdet CASCADE CONSTRAINTS;

DROP TABLE unitcode CASCADE CONSTRAINTS;

CREATE TABLE anidetailxref (
    ani_det_xref_id     INTEGER NOT NULL,
    event_id            INTEGER NOT NULL, 
--  Needed to resolve which container a fish or group of fish are relocated to.
--  Since an event can have multiple containers involved. And it is possible
--  that one group is housed in mutliple containers.
    container_xref_id   INTEGER,
    location_id         INTEGER,
    ind_treatment_id    INTEGER,
    indiv_id            INTEGER,
    spawn_id            INTEGER,
    group_id            INTEGER
);

COMMENT ON TABLE anidetailxref IS
    'Table that houses the data to cross reference various data on an animal to an event and, if pertinent, the location in the field or the facility.'
    ;

COMMENT ON COLUMN anidetailxref.ani_det_xref_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN anidetailxref.event_id IS
    'Links to the Events table.';

COMMENT ON COLUMN anidetailxref.container_xref_id IS
    'Links to the ContainersXRef table.';

COMMENT ON COLUMN anidetailxref.location_id IS
    'Links to the Locations table.';

COMMENT ON COLUMN anidetailxref.ind_treatment_id IS
    'Links to the IndTreatments table.';

COMMENT ON COLUMN anidetailxref.indiv_id IS
    'Links to the Individuals table.';

COMMENT ON COLUMN anidetailxref.spawn_id IS
    'Links to the SPawnings table.';

COMMENT ON COLUMN anidetailxref.group_id IS
    'Links to the Groups table.';

CREATE INDEX anidetailxref__idx ON
    anidetailxref (
        event_id
    ASC,
        container_xref_id
    ASC,
        location_id
    ASC );

CREATE INDEX anidetailxref__idxv1 ON
    anidetailxref (
        indiv_id
    ASC,
        group_id
    ASC,
        spawn_id
    ASC,
        ind_treatment_id
    ASC );

CREATE INDEX anidetailxref__idxv2 ON
    anidetailxref (
        event_id
    ASC );

CREATE INDEX anidetailxref__idxv3 ON
    anidetailxref (
        container_xref_id
    ASC );

CREATE INDEX anidetailxref__idxv4 ON
    anidetailxref (
        location_id
    ASC );

CREATE INDEX anidetailxref__idxv5 ON
    anidetailxref (
        ind_treatment_id
    ASC );

CREATE INDEX anidetailxref__idxv6 ON
    anidetailxref (
        indiv_id
    ASC );

CREATE INDEX anidetailxref__idxv7 ON
    anidetailxref (
        spawn_id
    ASC );

CREATE INDEX anidetailxref__idxv8 ON
    anidetailxref (
        group_id
    ASC );

ALTER TABLE anidetailxref
    ADD CONSTRAINT anidetailxref_ck_1 CHECK ( container_xref_id IS NOT NULL
                                              OR location_id IS NOT NULL
                                              OR ind_treatment_id IS NOT NULL
                                              OR indiv_id IS NOT NULL
                                              OR spawn_id IS NOT NULL
                                              OR group_id IS NOT NULL );

ALTER TABLE anidetailxref ADD CONSTRAINT anidetailxref_pk PRIMARY KEY ( ani_det_xref_id );

ALTER TABLE anidetailxref
    ADD CONSTRAINT anidetailxref__un UNIQUE ( container_xref_id,
                                              event_id,
                                              location_id,
                                              ind_treatment_id,
                                              indiv_id,
                                              spawn_id,
                                              group_id );

CREATE TABLE anidetsubjcode (
    ani_det_subj_id   INTEGER NOT NULL,
    ani_det_id        INTEGER NOT NULL,
    ani_subj_short    NUMBER(10) NOT NULL,
    ani_subj_desc     VARCHAR2(200) NOT NULL,
    created_by        VARCHAR2(32) NOT NULL,
    created_date      DATE NOT NULL
);

COMMENT ON TABLE anidetsubjcode IS
    'Table that houses the description of the observational, or subjective, information collected on individuals or groups of animals.'
    ;

COMMENT ON COLUMN anidetsubjcode.ani_det_subj_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN anidetsubjcode.ani_det_id IS
    'Links to the AniDetCodes table to describe the type of measurement.';

COMMENT ON COLUMN anidetsubjcode.ani_subj_short IS
    'Unigue, short description.';

COMMENT ON COLUMN anidetsubjcode.ani_subj_desc IS
    'Long description of the subjective value.';

COMMENT ON COLUMN anidetsubjcode.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN anidetsubjcode.created_date IS
    'Date that the record was input.';

CREATE INDEX anidetsubjcode__idx ON
    anidetsubjcode (
        ani_det_id
    ASC,
        ani_subj_short
    ASC );

CREATE INDEX anidetsubjcode__idxv1 ON
    anidetsubjcode (
        ani_det_id
    ASC );

CREATE INDEX anidetsubjcode__idxv2 ON
    anidetsubjcode (
        ani_subj_short
    ASC );

ALTER TABLE anidetsubjcode ADD CONSTRAINT anidetsubjcode_pk PRIMARY KEY ( ani_det_subj_id );

ALTER TABLE anidetsubjcode ADD CONSTRAINT anidetsubjcode__unv1 UNIQUE ( ani_subj_short );

CREATE TABLE animaldetcode (
    ani_det_id      INTEGER NOT NULL,
    ani_det_short   VARCHAR2(10 CHAR) NOT NULL,
    ani_det_desc    VARCHAR2(200 CHAR) NOT NULL,
    min_val         NUMBER(11, 5) NOT NULL,
    max_val         NUMBER(11, 5) NOT NULL,
    unit_id         INTEGER,
    ani_subj_flag   CHAR(1) NOT NULL,
    created_by      VARCHAR2(32 CHAR) NOT NULL,
    created_date    DATE NOT NULL
);

COMMENT ON TABLE animaldetcode IS
    'Table that houses the descriptions for the various meaurements or observations for either individuals or groups of fish.';

COMMENT ON COLUMN animaldetcode.ani_det_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN animaldetcode.ani_det_short IS
    'Unigue, short description.';

COMMENT ON COLUMN animaldetcode.ani_det_desc IS
    'The long description of the type of detail recorded for the individual or group.';

COMMENT ON COLUMN animaldetcode.min_val IS
    'The minimum value permitted for the measurement being recorded, used for quality control.';

COMMENT ON COLUMN animaldetcode.max_val IS
    'The maximum value permitted for the measurement being recorded, used for quality control.';

COMMENT ON COLUMN animaldetcode.unit_id IS
    'Links to the UnitCodes table to describe the unit of measure for the data.';

COMMENT ON COLUMN animaldetcode.ani_subj_flag IS
    'Flag to indicate if the detail is subjective or a true measurement.';

COMMENT ON COLUMN animaldetcode.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN animaldetcode.created_date IS
    'Date that the record was input.';

CREATE INDEX animaldetcode__idx ON
    animaldetcode (
        ani_det_short
    ASC );

CREATE INDEX animaldetcode__idxv1 ON
    animaldetcode (
        unit_id
    ASC );

CREATE INDEX animaldetcode__idxv2 ON
    animaldetcode (
        ani_subj_flag
    ASC );

ALTER TABLE animaldetcode
    ADD CONSTRAINT animaldetcode_ck_1 CHECK ( NOT ( ani_subj_flag = 'Y'
                                                    AND unit_id IS NOT NULL ) );

ALTER TABLE animaldetcode ADD CONSTRAINT animaldetcode_pk PRIMARY KEY ( ani_det_id );

ALTER TABLE animaldetcode ADD CONSTRAINT animaldetcode__un UNIQUE ( ani_det_short );

CREATE TABLE collection (
    collection_id      INTEGER NOT NULL,
    collection_short   VARCHAR2(20 CHAR) NOT NULL,
    collection_desc    VARCHAR2(60 CHAR) NOT NULL,
    created_by         VARCHAR2(32 CHAR) NOT NULL,
    created_date       DATE NOT NULL
);

COMMENT ON TABLE collection IS
    'Table that houses the descriptions of the possible collections for an animal or group of animals.';

COMMENT ON COLUMN collection.collection_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN collection.collection_short IS
    'Unigue, short description.';

COMMENT ON COLUMN collection.collection_desc IS
    'Long description for the collection.';

COMMENT ON COLUMN collection.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN collection.created_date IS
    'Date that the record was input.';

CREATE INDEX collection__idx ON
    collection (
        collection_short
    ASC );

ALTER TABLE collection ADD CONSTRAINT collection_pk PRIMARY KEY ( collection_id );

ALTER TABLE collection ADD CONSTRAINT collection__un UNIQUE ( collection_short );

CREATE TABLE containerdetcode (
    cont_det_id      INTEGER NOT NULL,
    cont_det_short   VARCHAR2(10 CHAR) NOT NULL,
    cont_det_desc    VARCHAR2(35 CHAR) NOT NULL,
    min_val          NUMBER(11, 5) NOT NULL,
    max_val          NUMBER(11, 5) NOT NULL,
    unit_id          INTEGER,
    cont_subj_flag   CHAR(1) NOT NULL,
    created_by       VARCHAR2(32 CHAR) NOT NULL,
    created_date     DATE NOT NULL
);

COMMENT ON TABLE containerdetcode IS
    'Table that describes the various types of details which may be recorded for a container.';

COMMENT ON COLUMN containerdetcode.cont_det_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN containerdetcode.cont_det_short IS
    'Unigue, short description.';

COMMENT ON COLUMN containerdetcode.cont_det_desc IS
    'Longer description of the type of detail recorded for the container.';

COMMENT ON COLUMN containerdetcode.min_val IS
    'The minimum value permitted for the measurement being recorded, used for quality control.';

COMMENT ON COLUMN containerdetcode.max_val IS
    'The maximum value permitted for the measurement being recorded, used for quality control.';

COMMENT ON COLUMN containerdetcode.unit_id IS
    'The unit of measure for the detail, if not a subjective observation.';

COMMENT ON COLUMN containerdetcode.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN containerdetcode.created_date IS
    'Date that the record was input.';

CREATE INDEX containerdetcode__idx ON
    containerdetcode (
        cont_det_short
    ASC );

CREATE INDEX containerdetcode__idxv1 ON
    containerdetcode (
        unit_id
    ASC );

CREATE INDEX containerdetcode__idxv3 ON
    containerdetcode (
        cont_subj_flag
    ASC );

ALTER TABLE containerdetcode
    ADD CONSTRAINT containerdetcode_ck_1 CHECK ( NOT ( cont_subj_flag = 'Y'
                                                       AND unit_id IS NOT NULL ) );

ALTER TABLE containerdetcode ADD CONSTRAINT containerdetcode_pk PRIMARY KEY ( cont_det_id );

ALTER TABLE containerdetcode ADD CONSTRAINT containerdetcode__un UNIQUE ( cont_det_short );

CREATE TABLE containerxref (
    container_xref_id   INTEGER NOT NULL,
    event_id            INTEGER NOT NULL,
    tank_id             INTEGER,
    trough_id           INTEGER,
    tray_id             INTEGER,
    heath_unit_id       INTEGER,
    drawer_id           INTEGER,
    cup_id              INTEGER
);

COMMENT ON TABLE containerxref IS
    'Table to cross reference from the various unique containers for housing the fish to the Events table. This table allows for containers within a container, for example which tray is in which trough of a facility and when. Also used to link either an individual or group to the container which they are, or were at one time, housed in. Allows for keeping the history of where an individual has been over the time at the facility.'
    ;

COMMENT ON COLUMN containerxref.container_xref_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN containerxref.event_id IS
    'Links to the Events table.';

COMMENT ON COLUMN containerxref.tank_id IS
    'Links to the Tanks table.';

COMMENT ON COLUMN containerxref.trough_id IS
    'Links to the Troughs table.';

COMMENT ON COLUMN containerxref.tray_id IS
    'Links to the Trays table.';

COMMENT ON COLUMN containerxref.heath_unit_id IS
    'Links to the HeathUnits table.';

COMMENT ON COLUMN containerxref.drawer_id IS
    'Links to the Drawers table.';

COMMENT ON COLUMN containerxref.cup_id IS
    'Links to the Cups table.';

CREATE INDEX containerxref__idx ON
    containerxref (
        event_id
    ASC,
        tank_id
    ASC,
        trough_id
    ASC,
        tray_id
    ASC,
        heath_unit_id
    ASC,
        drawer_id
    ASC,
        cup_id
    ASC );

CREATE INDEX containerxref__idxv1 ON
    containerxref (
        event_id
    ASC );

CREATE INDEX containerxref__idxv2 ON
    containerxref (
        tank_id
    ASC );

CREATE INDEX containerxref__idxv3 ON
    containerxref (
        trough_id
    ASC );

CREATE INDEX containerxref__idxv4 ON
    containerxref (
        tray_id
    ASC );

CREATE INDEX containerxref__idxv5 ON
    containerxref (
        heath_unit_id
    ASC );

CREATE INDEX containerxref__idxv6 ON
    containerxref (
        drawer_id
    ASC );

CREATE INDEX containerxref__idxv7 ON
    containerxref (
        cup_id
    ASC );

ALTER TABLE containerxref
    ADD CONSTRAINT containerxref_ck_1 CHECK ( tank_id IS NOT NULL
                                              OR trough_id IS NOT NULL
                                              OR tray_id IS NOT NULL
                                              OR heath_unit_id IS NOT NULL
                                              OR drawer_id IS NOT NULL
                                              OR cup_id IS NOT NULL );

ALTER TABLE containerxref ADD CONSTRAINT containerxref_pk PRIMARY KEY ( container_xref_id );

ALTER TABLE containerxref
    ADD CONSTRAINT containerxref__un UNIQUE ( event_id,
                                              tank_id,
                                              trough_id,
                                              tray_id,
                                              heath_unit_id,
                                              drawer_id,
                                              cup_id );

CREATE TABLE contdetsubjcode (
    cont_det_subj_id      INTEGER NOT NULL,
    cont_det_id           INTEGER NOT NULL,
    cont_det_subj_short   VARCHAR2(15 CHAR) NOT NULL,
    cont_det_subj_desc    VARCHAR2(200 CHAR) NOT NULL,
    created_by            VARCHAR2(32 CHAR) NOT NULL,
    created_date          DATE NOT NULL
);

COMMENT ON TABLE contdetsubjcode IS
    'Table that describes the types of observational, or subjective, data recorded for a container.';

COMMENT ON COLUMN contdetsubjcode.cont_det_subj_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN contdetsubjcode.cont_det_id IS
    'Links to the ContainerDetCodes table to identify the type of observation.';

COMMENT ON COLUMN contdetsubjcode.cont_det_subj_short IS
    'Unigue, short description.';

COMMENT ON COLUMN contdetsubjcode.cont_det_subj_desc IS
    'Longer description of the subjective observation.';

COMMENT ON COLUMN contdetsubjcode.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN contdetsubjcode.created_date IS
    'Date that the record was input.';

CREATE INDEX contdetsubjcode__idx ON
    contdetsubjcode (
        cont_det_id
    ASC,
        cont_det_subj_short
    ASC );

CREATE INDEX contdetsubjcode__idxv1 ON
    contdetsubjcode (
        cont_det_id
    ASC );

CREATE INDEX contdetsubjcode__idxv2 ON
    contdetsubjcode (
        cont_det_subj_short
    ASC );

ALTER TABLE contdetsubjcode ADD CONSTRAINT contdetsubjcode_pk PRIMARY KEY ( cont_det_subj_id );

ALTER TABLE contdetsubjcode
    ADD CONSTRAINT contdetsubjcode__un UNIQUE ( cont_det_subj_id,
                                                cont_det_id,
                                                cont_det_subj_short );

--  There may be a variety of count type events. In the field it may be by
--  species, and by sex and life history stage. At the facility they may be
--  counting the number of animals at different stages of development in a tray
--  for example....
CREATE TABLE count (
    count_id            INTEGER NOT NULL,
    location_id         INTEGER,
    container_xref_id   INTEGER,
    cnt_id              INTEGER NOT NULL,
    spec_id             INTEGER NOT NULL,
    count               NUMBER(6) NOT NULL,
    estimated           CHAR(1) NOT NULL,
    comments            VARCHAR2(2000 CHAR),
    created_by          VARCHAR2(32 CHAR) NOT NULL,
    created_date        DATE NOT NULL
);

COMMENT ON TABLE count IS
    'Table that houses information on the count of animals, either in the field or in the facility.';

COMMENT ON COLUMN count.count_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN count.location_id IS
    'Links to the Locations table for information on where and when the count was done in the field.';

COMMENT ON COLUMN count.container_xref_id IS
    'Links to the COntainersXRef table.';

COMMENT ON COLUMN count.cnt_id IS
    'Links to the CountCodes table to describe the type of count performed.';

COMMENT ON COLUMN count.spec_id IS
    'Links to the SpeciesCodes table to describe the species type being counted.';

COMMENT ON COLUMN count.count IS
    'The total count.';

COMMENT ON COLUMN count.estimated IS
    'Is the count an estimated number? A boolean field, T or F.';

COMMENT ON COLUMN count.comments IS
    'Comments regarding the data in this record.';

COMMENT ON COLUMN count.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN count.created_date IS
    'Date that the record was input.';

CREATE INDEX count__idx ON
    count (
        location_id
    ASC,
        container_xref_id
    ASC,
        cnt_id
    ASC,
        spec_id
    ASC );

CREATE INDEX count__idxv1 ON
    count (
        estimated
    ASC );

CREATE INDEX count__idxv2 ON
    count (
        location_id
    ASC );

CREATE INDEX count__idxv3 ON
    count (
        container_xref_id
    ASC );

CREATE INDEX count__idxv4 ON
    count (
        cnt_id
    ASC );

CREATE INDEX count__idxv5 ON
    count (
        spec_id
    ASC );

ALTER TABLE count
    ADD CONSTRAINT count_ck_1 CHECK ( location_id IS NOT NULL
                                      OR container_xref_id IS NOT NULL );

ALTER TABLE count ADD CONSTRAINT count_pk PRIMARY KEY ( count_id );

ALTER TABLE count
    ADD CONSTRAINT count__un UNIQUE ( location_id,
                                      container_xref_id,
                                      cnt_id,
                                      spec_id );

CREATE TABLE countcode (
    cnt_id         INTEGER NOT NULL,
    cnt_short      VARCHAR2(10 CHAR) NOT NULL,
    cnt_desc       VARCHAR2(50 CHAR),
    created_by     VARCHAR2(32 CHAR) NOT NULL,
    created_date   DATE NOT NULL
);

COMMENT ON TABLE countcode IS
    'Table that describes the type of count being done on a container or location. Examples include egg counts, mortalities, and inventories.'
    ;

COMMENT ON COLUMN countcode.cnt_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN countcode.cnt_short IS
    'Unigue, short description.';

COMMENT ON COLUMN countcode.cnt_desc IS
    'The long description of the type of count.';

COMMENT ON COLUMN countcode.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN countcode.created_date IS
    'Date that the record was input.';

CREATE INDEX countcode__idx ON
    countcode (
        cnt_short
    ASC );

ALTER TABLE countcode ADD CONSTRAINT countcode_pk PRIMARY KEY ( cnt_id );

ALTER TABLE countcode ADD CONSTRAINT countcode__un UNIQUE ( cnt_short );

CREATE TABLE countdet (
    count_det_id      INTEGER NOT NULL,
    count_id          INTEGER NOT NULL,
    ani_det_id        INTEGER NOT NULL,
    val               NUMBER(11, 5),
    ani_det_subj_id   INTEGER,
    qual_id           INTEGER NOT NULL,
    comments          VARCHAR2(2000 CHAR),
    created_by        VARCHAR2(32 CHAR) NOT NULL,
    created_date      DATE NOT NULL
);

COMMENT ON TABLE countdet IS
    'Table that houses the detials on the count performed.';

COMMENT ON COLUMN countdet.count_det_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN countdet.count_id IS
    'Links to the Counts table for the detail.';

COMMENT ON COLUMN countdet.ani_det_id IS
    'Links to the AniDetCodes table to describe the type of measurement.';

COMMENT ON COLUMN countdet.val IS
    'The value of the measurement if not a subjective observation.';

COMMENT ON COLUMN countdet.ani_det_subj_id IS
    'Links to the AniDetSubjCodes table to describe the subjective measurement.';

COMMENT ON COLUMN countdet.qual_id IS
    'Links to the QualCOdes table.';

COMMENT ON COLUMN countdet.comments IS
    'Comments regarding the data in this record.';

COMMENT ON COLUMN countdet.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN countdet.created_date IS
    'Date that the record was input.';

CREATE INDEX countdet__idx ON
    countdet (
        count_id
    ASC,
        ani_det_id
    ASC,
        ani_det_subj_id
    ASC );

CREATE INDEX countdet__idxv1 ON
    countdet (
        qual_id
    ASC );

CREATE INDEX countdet__idxv2 ON
    countdet (
        count_id
    ASC );

CREATE INDEX countdet__idxv3 ON
    countdet (
        ani_det_id
    ASC );

CREATE INDEX countdet__idxv4 ON
    countdet (
        ani_det_subj_id
    ASC );

ALTER TABLE countdet
    ADD CONSTRAINT countdet_ck_1 CHECK ( val IS NOT NULL
                                         OR ani_det_subj_id IS NOT NULL );

ALTER TABLE countdet ADD CONSTRAINT countdet_pk PRIMARY KEY ( count_det_id );

ALTER TABLE countdet
    ADD CONSTRAINT countdet__un UNIQUE ( count_id,
                                         ani_det_id,
                                         ani_det_subj_id );

CREATE TABLE cup (
    cup_id         INTEGER NOT NULL,
    cup_short      VARCHAR2(10 CHAR) NOT NULL,
    cup_desc       VARCHAR2(35 CHAR),
    created_by     VARCHAR2(32 CHAR) NOT NULL,
    created_date   DATE NOT NULL
);

COMMENT ON TABLE cup IS
    'Table that uniquely identifies the cups in use in the facilities.';

COMMENT ON COLUMN cup.cup_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN cup.cup_short IS
    'Unigue, short description.';

COMMENT ON COLUMN cup.cup_desc IS
    'Longer description of the cup.';

COMMENT ON COLUMN cup.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN cup.created_date IS
    'Date that the record was input.';

CREATE INDEX cup__idx ON
    cup (
        cup_short
    ASC );

ALTER TABLE cup ADD CONSTRAINT cup_pk PRIMARY KEY ( cup_id );

ALTER TABLE cup ADD CONSTRAINT cup__un UNIQUE ( cup_short );

CREATE TABLE cupdet (
    cup_det_id         INTEGER NOT NULL,
    cup_id             INTEGER NOT NULL,
    cont_det_id        INTEGER NOT NULL,
    val                NUMBER(11, 5),
    cont_det_subj_id   INTEGER,
    cup_det_start      DATE NOT NULL,
    cup_det_end        DATE,
    still_valid        CHAR(1) NOT NULL,
    comments           VARCHAR2(2000 CHAR),
    created_by         VARCHAR2(32 CHAR) NOT NULL,
    created_date       DATE NOT NULL
);

COMMENT ON TABLE cupdet IS
    'Table that houses the various details for a cup.';

COMMENT ON COLUMN cupdet.cup_det_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN cupdet.cup_id IS
    'Links to the Cups table.';

COMMENT ON COLUMN cupdet.cont_det_id IS
    'Links to the ContainerDetCodes table to describe the type of detail recorded.';

COMMENT ON COLUMN cupdet.val IS
    'The value of the measurement if not a subjective observation.';

COMMENT ON COLUMN cupdet.cont_det_subj_id IS
    'Links to the ContDetSubjCodes table to describe the observation.';

COMMENT ON COLUMN cupdet.cup_det_start IS
    'The date that the detail was recorded, mandatory.';

COMMENT ON COLUMN cupdet.cup_det_end IS
    'The last date which the detail is still valid.';

COMMENT ON COLUMN cupdet.still_valid IS
    'Boolean, Y or N, that indicates whether this record is still valid,  used to filter in the application and for reporting purposes.'
    ;

COMMENT ON COLUMN cupdet.comments IS
    'Comments regarding the data in this record.';

COMMENT ON COLUMN cupdet.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN cupdet.created_date IS
    'Date that the record was input.';

CREATE INDEX cupdet__idx ON
    cupdet (
        cup_id
    ASC,
        cont_det_id
    ASC,
        cont_det_subj_id
    ASC );

CREATE INDEX cupdet__idxv1 ON
    cupdet (
        still_valid
    ASC );

CREATE INDEX cupdet__idxv2 ON
    cupdet (
        cup_id
    ASC );

CREATE INDEX cupdet__idxv3 ON
    cupdet (
        cont_det_id
    ASC );

CREATE INDEX cupdet__idxv4 ON
    cupdet (
        cont_det_subj_id
    ASC );

ALTER TABLE cupdet
    ADD CONSTRAINT cupdet_ck_1 CHECK ( val IS NOT NULL
                                       OR cont_det_subj_id IS NOT NULL );

ALTER TABLE cupdet ADD CONSTRAINT cupdet_pk PRIMARY KEY ( cup_det_id );

ALTER TABLE cupdet
    ADD CONSTRAINT cupdet__un UNIQUE ( cup_id,
                                       cont_det_id,
                                       cont_det_subj_id,
                                       cup_det_start );

CREATE TABLE drawer (
    drawer_id      INTEGER NOT NULL,
    drawer_short   VARCHAR2(10 CHAR) NOT NULL,
    drawer_desc    VARCHAR2(35 CHAR) NOT NULL,
    created_by     VARCHAR2(32 CHAR) NOT NULL,
    created_date   DATE NOT NULL
);

COMMENT ON TABLE drawer IS
    'Table that uniquely identifes the drawers in the heath units.';

COMMENT ON COLUMN drawer.drawer_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN drawer.drawer_short IS
    'Unigue, short description.';

COMMENT ON COLUMN drawer.drawer_desc IS
    'Longer description of the container.';

COMMENT ON COLUMN drawer.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN drawer.created_date IS
    'Date that the record was input.';

CREATE INDEX drawer__idx ON
    drawer (
        drawer_short
    ASC );

ALTER TABLE drawer ADD CONSTRAINT drawer_pk PRIMARY KEY ( drawer_id );

ALTER TABLE drawer ADD CONSTRAINT drawer__un UNIQUE ( drawer_short );

CREATE TABLE envcode (
    env_id          INTEGER NOT NULL,
    env_short       VARCHAR2(10 CHAR) NOT NULL,
    env_desc        VARCHAR2(500 CHAR) NOT NULL,
    min_val         NUMBER(11, 5) NOT NULL,
    max_val         NUMBER(11, 5) NOT NULL,
    unit_id         INTEGER,
    env_subj_flag   CHAR(1) NOT NULL,
    created_by      VARCHAR2(32 CHAR) NOT NULL,
    created_date    DATE NOT NULL
);

COMMENT ON TABLE envcode IS
    'Table that describes the type of environmental conditions being collected. The condition may either be a true measurement (ie temperature) or  subjective observations (ie strong current).'
    ;

COMMENT ON COLUMN envcode.env_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN envcode.env_short IS
    'Short unique description of the type of variable.';

COMMENT ON COLUMN envcode.env_desc IS
    'Long description of the variable.';

COMMENT ON COLUMN envcode.min_val IS
    'The minimum valid value for the measurement, used for quality assurance.';

COMMENT ON COLUMN envcode.max_val IS
    'The maximum valid value of the measurement, used in quality assurance.';

COMMENT ON COLUMN envcode.unit_id IS
    'Links to the UnitCodes table for the description of the unit of measure for the variable.';

COMMENT ON COLUMN envcode.env_subj_flag IS
    'Flag indicating if the type of measurement is observationl, or subjective. Boolean, Y or N.';

COMMENT ON COLUMN envcode.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN envcode.created_date IS
    'Date that the record was input.';

CREATE INDEX envcode__idx ON
    envcode (
        env_short
    ASC );

CREATE INDEX envcode__idxv1 ON
    envcode (
        unit_id
    ASC );

CREATE INDEX envcode__idxv2 ON
    envcode (
        env_subj_flag
    ASC );

ALTER TABLE envcode
    ADD CONSTRAINT envcode_ck_1 CHECK ( NOT ( env_subj_flag = 'Y'
                                              AND unit_id IS NOT NULL ) );

ALTER TABLE envcode ADD CONSTRAINT envcode_pk PRIMARY KEY ( env_id );

ALTER TABLE envcode ADD CONSTRAINT envcode__un UNIQUE ( env_short );

CREATE TABLE envcondfile (
    env_cond_file_id   INTEGER NOT NULL,
    env_cond_id        INTEGER NOT NULL,
    raw_file           BLOB NOT NULL,
    comments           VARCHAR2(2000 CHAR),
    created_by         VARCHAR2(32 CHAR) NOT NULL,
    created_date       DATE NOT NULL
);

COMMENT ON TABLE envcondfile IS
    'Table that houses files created when recording enviromental conditions. For example the file from a temperature recorder deployed to a tank or a field location.'
    ;

COMMENT ON COLUMN envcondfile.env_cond_file_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN envcondfile.env_cond_id IS
    'Links to EnvConditions table.';

COMMENT ON COLUMN envcondfile.raw_file IS
    'The file which contains the data associated with the environmental condition monitoring.';

COMMENT ON COLUMN envcondfile.comments IS
    'Comments regarding the data in this record.';

COMMENT ON COLUMN envcondfile.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN envcondfile.created_date IS
    'Date that the record was input.';

CREATE INDEX envcondfile__idx ON
    envcondfile (
        env_cond_id
    ASC );

ALTER TABLE envcondfile ADD CONSTRAINT envcondfile_pk PRIMARY KEY ( env_cond_file_id );

ALTER TABLE envcondfile ADD CONSTRAINT envcondfile__un UNIQUE ( env_cond_id );

CREATE TABLE envcondition (
    env_cond_id           INTEGER NOT NULL,
    container_xref_id     INTEGER,
    location_id           INTEGER,
    instrum_id            INTEGER NOT NULL,
    env_id                INTEGER NOT NULL,
    val                   NUMBER(11, 5),
    env_subj_id           INTEGER,
    env_cond_start        DATE NOT NULL,
    env_cond_start_time   NUMBER(4),
    env_cond_end          DATE,
    env_cond_end_time     NUMBER(4),
    averaged              CHAR(1) NOT NULL,
    qual_id               INTEGER NOT NULL,
    comments              VARCHAR2(2000 CHAR),
    created_by            VARCHAR2(32 CHAR) NOT NULL,
    created_date          DATE NOT NULL
);

COMMENT ON TABLE envcondition IS
    'Table that houses the information related to environmental conditions collected for either a location in the field or a container at the facility.'
    ;

COMMENT ON COLUMN envcondition.env_cond_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN envcondition.container_xref_id IS
    'Links to the ContainersXRef table.';

COMMENT ON COLUMN envcondition.location_id IS
    'Links to the Locatiions table.';

COMMENT ON COLUMN envcondition.instrum_id IS
    'Links to the Instruments table.';

COMMENT ON COLUMN envcondition.env_id IS
    'The environmental vairable of the value.';

COMMENT ON COLUMN envcondition.val IS
    'The value of the measurement if not a subjective observation.';

COMMENT ON COLUMN envcondition.env_subj_id IS
    'Links to the EnvSubjCodes table to describe the observation recorded.';

COMMENT ON COLUMN envcondition.env_cond_start IS
    'The start date of the recording of the conditions.';

COMMENT ON COLUMN envcondition.env_cond_start_time IS
    'The start time of the monitoring, valid entires are 1 to 2400. Time is local time. Optional.';

COMMENT ON COLUMN envcondition.env_cond_end IS
    'The end date of the recording of the conditions.';

COMMENT ON COLUMN envcondition.env_cond_end_time IS
    'The start time of the monitoring, valid entires are 1 to 2400. Time is local time. Optional.';

COMMENT ON COLUMN envcondition.averaged IS
    'Is the value the result of averaging over the start and end of the data collection?';

COMMENT ON COLUMN envcondition.qual_id IS
    'Links to the QualCodes table to describe the confidence in the value recorded.';

COMMENT ON COLUMN envcondition.comments IS
    'Comments regarding the data in this record.';

COMMENT ON COLUMN envcondition.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN envcondition.created_date IS
    'Date that the record was input.';

CREATE INDEX envcondition__idx ON
    envcondition (
        container_xref_id
    ASC,
        location_id
    ASC );

CREATE INDEX envcondition__idxv1 ON
    envcondition (
        env_id
    ASC,
        instrum_id
    ASC,
        env_subj_id
    ASC );

CREATE INDEX envcondition__idxv2 ON
    envcondition (
        averaged
    ASC );

CREATE INDEX envcondition__idxv3 ON
    envcondition (
        qual_id
    ASC );

CREATE INDEX envcondition__idxv4 ON
    envcondition (
        container_xref_id
    ASC );

CREATE INDEX envcondition__idxv5 ON
    envcondition (
        location_id
    ASC );

CREATE INDEX envcondition__idxv6 ON
    envcondition (
        instrum_id
    ASC );

CREATE INDEX envcondition__idxv7 ON
    envcondition (
        env_id
    ASC );

CREATE INDEX envcondition__idxv8 ON
    envcondition (
        env_subj_id
    ASC );

ALTER TABLE envcondition
    ADD CONSTRAINT envcondition_ck_1 CHECK ( val IS NOT NULL
                                             OR env_subj_id IS NOT NULL );

ALTER TABLE envcondition ADD CONSTRAINT envcondition_pk PRIMARY KEY ( env_cond_id );

ALTER TABLE envcondition
    ADD CONSTRAINT envcondition__un UNIQUE ( container_xref_id,
                                             location_id,
                                             instrum_id );

CREATE TABLE envsubjcode (
    env_subj_id      INTEGER NOT NULL,
    env_id           INTEGER NOT NULL,
    env_subj_short   VARCHAR2(10 CHAR) NOT NULL,
    env_subj_desc    VARCHAR2(200 CHAR) NOT NULL,
    created_by       VARCHAR2(32 CHAR) NOT NULL,
    created_date     DATE NOT NULL
);

COMMENT ON TABLE envsubjcode IS
    'Table that describes the subjective, or observational, types of environmental condition being recorded.';

COMMENT ON COLUMN envsubjcode.env_subj_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN envsubjcode.env_id IS
    'Links to the EnvCodes table to describe the type of information the subjective values are for.';

COMMENT ON COLUMN envsubjcode.env_subj_short IS
    'Unigue, short description.';

COMMENT ON COLUMN envsubjcode.env_subj_desc IS
    'Long description of the variable.';

COMMENT ON COLUMN envsubjcode.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN envsubjcode.created_date IS
    'Date that the record was input.';

CREATE INDEX envsubjcode__idx ON
    envsubjcode (
        env_subj_short
    ASC );

CREATE INDEX envsubjcode__idxv3 ON
    envsubjcode (
        env_id
    ASC,
        env_subj_short
    ASC );

ALTER TABLE envsubjcode ADD CONSTRAINT envsubjcode_pk PRIMARY KEY ( env_subj_id );

ALTER TABLE envsubjcode ADD CONSTRAINT envsubjcode__unv1 UNIQUE ( env_subj_short );

CREATE TABLE envtreatment (
    env_treatment_id    INTEGER NOT NULL,
    container_xref_id   INTEGER NOT NULL,
    env_treat_id        INTEGER NOT NULL,
    lot_number          VARCHAR2(30 CHAR) NOT NULL,
    amount              NUMBER(9, 3) NOT NULL,
    unit_id             INTEGER NOT NULL,
    duration            NUMBER(5) NOT NULL,
    comments            VARCHAR2(2000 CHAR),
    created_by          VARCHAR2(32 CHAR) NOT NULL,
    created_date        DATE NOT NULL
);

COMMENT ON TABLE envtreatment IS
    'Table that houses information on treatments performed on a container of animals. For example antifungal agent added to a tank.'
    ;

COMMENT ON COLUMN envtreatment.env_treatment_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN envtreatment.container_xref_id IS
    'Links to the ContainersXRef table.';

COMMENT ON COLUMN envtreatment.env_treat_id IS
    'Links to the EnvTreatCodes for the description of the type of treatment.';

COMMENT ON COLUMN envtreatment.lot_number IS
    'Lot number of the product used in the treatment.';

COMMENT ON COLUMN envtreatment.amount IS
    'Amount of the product used.';

COMMENT ON COLUMN envtreatment.unit_id IS
    'Links to the UnitCodes table for the unit of measure of the treatment.';

COMMENT ON COLUMN envtreatment.duration IS
    'The duration, in minutes, of the treatment.';

COMMENT ON COLUMN envtreatment.comments IS
    'Comments regarding the data in this record.';

COMMENT ON COLUMN envtreatment.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN envtreatment.created_date IS
    'Date that the record was input.';

CREATE INDEX envtreatment__idx ON
    envtreatment (
        container_xref_id
    ASC,
        env_treat_id
    ASC );

CREATE INDEX envtreatment__idxv1 ON
    envtreatment (
        lot_number
    ASC );

CREATE INDEX envtreatment__idxv2 ON
    envtreatment (
        unit_id
    ASC );

CREATE INDEX envtreatment__idxv3 ON
    envtreatment (
        container_xref_id
    ASC );

CREATE INDEX envtreatment__idxv4 ON
    envtreatment (
        env_treat_id
    ASC );

ALTER TABLE envtreatment ADD CONSTRAINT envtreatment_pk PRIMARY KEY ( env_treatment_id );

ALTER TABLE envtreatment ADD CONSTRAINT envtreatment__un UNIQUE ( container_xref_id,
                                                                  env_treat_id );

CREATE TABLE envtreatmentcode (
    env_treat_id      INTEGER NOT NULL,
    env_treat_short   VARCHAR2(10 CHAR) NOT NULL,
    env_treat_desc    VARCHAR2(35 CHAR) NOT NULL,
    env_rec_dosage    VARCHAR2(250 CHAR) NOT NULL,
    manufacturer      VARCHAR2(50 CHAR),
    created_by        VARCHAR2(32 CHAR) NOT NULL,
    created_date      DATE NOT NULL
);

COMMENT ON TABLE envtreatmentcode IS
    'Table that houses the information for treatments which may be used in the various containers of a facility.';

COMMENT ON COLUMN envtreatmentcode.env_treat_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN envtreatmentcode.env_treat_short IS
    'Unigue, short description.';

COMMENT ON COLUMN envtreatmentcode.env_treat_desc IS
    'Long description of the environmental treatment type.';

COMMENT ON COLUMN envtreatmentcode.env_rec_dosage IS
    'Amount of the product prescribed by the manufacturer.';

COMMENT ON COLUMN envtreatmentcode.manufacturer IS
    'The manufacturer of the product.';

COMMENT ON COLUMN envtreatmentcode.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN envtreatmentcode.created_date IS
    'Date that the record was input.';

CREATE INDEX envtreatmentcode__idx ON
    envtreatmentcode (
        env_treat_short
    ASC );

CREATE INDEX envtreatmentcode__idxv1 ON
    envtreatmentcode (
        manufacturer
    ASC );

ALTER TABLE envtreatmentcode ADD CONSTRAINT envtreatmentcode_pk PRIMARY KEY ( env_treat_id );

ALTER TABLE envtreatmentcode ADD CONSTRAINT envtreatmentcode__un UNIQUE ( env_treat_short );

CREATE TABLE event (
    event_id           INTEGER NOT NULL,
    fac_id             INTEGER NOT NULL,
    evt_id             INTEGER NOT NULL,
    per_id             INTEGER NOT NULL,
    program_id         INTEGER NOT NULL,
    team_id            INTEGER,
    event_start        DATE NOT NULL,
    event_start_time   NUMBER(4),
    event_end          DATE NOT NULL,
    event_end_time     NUMBER(4),
    comments           VARCHAR2(2000 CHAR),
    created_by         VARCHAR2(32 CHAR) NOT NULL,
    created_date       DATE NOT NULL
);

ALTER TABLE event ADD CHECK ( event_start_time BETWEEN 1 AND 2400 );

ALTER TABLE event ADD CHECK ( event_end_time BETWEEN 1 AND 2400 );

COMMENT ON TABLE event IS
    'Information that describes an event, or work task. Includes the who, what, and when. An event may span multiple days (spawning) or take place within a single day. Events may affect many animals or only a single individual animal. Moving a group of animals from one location to another would be an event for example.'
    ;

COMMENT ON COLUMN event.event_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN event.fac_id IS
    'Foreign key to the Facilities table which describes the facility performing the work for the event.';

COMMENT ON COLUMN event.evt_id IS
    'Links to the EventCodes table to describe the type of event taking place.';

COMMENT ON COLUMN event.per_id IS
    'Links to the PersonnelCodes table. If the work is performed by a team the team leader, or if solitary work, the person performing the task.'
    ;

COMMENT ON COLUMN event.program_id IS
    'Optional, links to a specific program, used if the event is specific to a program.';

COMMENT ON COLUMN event.team_id IS
    'Links to the Teams table. Describes the members and their roles for the team, if applicable, for the event.';

COMMENT ON COLUMN event.event_start IS
    'Start date of the event.';

COMMENT ON COLUMN event.event_start_time IS
    'The start time of the event, valid entires are 1 to 2400. Time is local time.';

COMMENT ON COLUMN event.event_end IS
    'End date of event.';

COMMENT ON COLUMN event.event_end_time IS
    'The end time of the event, valid entires are 1 to 2400. Time is local time.';

COMMENT ON COLUMN event.comments IS
    'Comments regarding the data in this record.';

COMMENT ON COLUMN event.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN event.created_date IS
    'Date that the record was input.';

CREATE INDEX event__idx ON
    event (
        fac_id
    ASC,
        evt_id
    ASC,
        per_id
    ASC,
        program_id
    ASC,
        team_id
    ASC );

CREATE INDEX event__idxv1 ON
    event (
        fac_id
    ASC );

CREATE INDEX event__idxv2 ON
    event (
        evt_id
    ASC );

CREATE INDEX event__idxv3 ON
    event (
        per_id
    ASC );

CREATE INDEX event__idxv4 ON
    event (
        program_id
    ASC );

CREATE INDEX event__idxv5 ON
    event (
        team_id
    ASC );

ALTER TABLE event ADD CONSTRAINT event_pk PRIMARY KEY ( event_id );

ALTER TABLE event
    ADD CONSTRAINT event__un UNIQUE ( fac_id,
                                      evt_id,
                                      program_id,
                                      event_start,
                                      event_end );

CREATE TABLE eventcode (
    evt_id         INTEGER NOT NULL,
    evt_short      VARCHAR2(10 CHAR),
    evt_desc       VARCHAR2(500 CHAR),
    created_by     VARCHAR2(32 CHAR) NOT NULL,
    created_date   DATE NOT NULL
);

COMMENT ON TABLE eventcode IS
    'Table that describes the different types of events which may take place. Possible examples are spawning, field sampling, or counting of eggs.'
    ;

COMMENT ON COLUMN eventcode.evt_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN eventcode.evt_short IS
    'Unigue, short description.';

COMMENT ON COLUMN eventcode.evt_desc IS
    'Long description of the type of event.';

COMMENT ON COLUMN eventcode.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN eventcode.created_date IS
    'Date that the record was input.';

CREATE INDEX eventcode__idx ON
    eventcode (
        evt_short
    ASC );

ALTER TABLE eventcode ADD CONSTRAINT eventcode_pk PRIMARY KEY ( evt_id );

ALTER TABLE eventcode ADD CONSTRAINT eventcode__un UNIQUE ( evt_short );

CREATE TABLE facilitycode (
    fac_id         INTEGER NOT NULL,
    fac_short      VARCHAR2(10 CHAR) NOT NULL,
    fac_desc       VARCHAR2(30 CHAR) NOT NULL,
    created_by     VARCHAR2(32 CHAR) NOT NULL,
    created_date   DATE NOT NULL
);

COMMENT ON TABLE facilitycode IS
    'Table used house the information on the facilities.';

COMMENT ON COLUMN facilitycode.fac_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN facilitycode.fac_short IS
    'Unigue, short description.';

COMMENT ON COLUMN facilitycode.fac_desc IS
    'Long name of the facility';

COMMENT ON COLUMN facilitycode.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN facilitycode.created_date IS
    'Date that the record was input.';

CREATE INDEX facilitycode__idx ON
    facilitycode (
        fac_short
    ASC );

ALTER TABLE facilitycode ADD CONSTRAINT facilitycode_pk PRIMARY KEY ( fac_id );

ALTER TABLE facilitycode ADD CONSTRAINT facilitycode__un UNIQUE ( fac_short );

CREATE TABLE fecundity (
    fec_id          INTEGER NOT NULL,
    stock_id        INTEGER NOT NULL,
    collection_id   INTEGER,
    fec_start       DATE NOT NULL,
    fec_end         DATE,
    a               NUMBER(10, 3) NOT NULL,
    b               NUMBER(10, 3) NOT NULL,
    still_valid     CHAR(1) NOT NULL,
    comments        VARCHAR2(2000 CHAR),
    created_by      VARCHAR2(32 CHAR) NOT NULL,
    created_date    DATE NOT NULL
);

COMMENT ON TABLE fecundity IS
    'Table that houses the information required to estimate fecundity of a dam during a spawning. Including the  long term history of this information and changes over time.'
    ;

COMMENT ON COLUMN fecundity.fec_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN fecundity.stock_id IS
    'Links to the StockCodes table to identify the stock.';

COMMENT ON COLUMN fecundity.collection_id IS
    'Links to the Collections table to describe the collection.';

COMMENT ON COLUMN fecundity.fec_start IS
    'Start date of the use of these information for arriving at the estimated fecundity of a female.';

COMMENT ON COLUMN fecundity.fec_end IS
    'The last date that this information was used for estimation of fecundity.';

COMMENT ON COLUMN fecundity.still_valid IS
    'Boolean, Y or N, that indicates whether this record is still valid,  used to filter in the application and for reporting purposes.'
    ;

COMMENT ON COLUMN fecundity.comments IS
    'Comments regarding the data in this record.';

COMMENT ON COLUMN fecundity.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN fecundity.created_date IS
    'Date that the record was input.';

CREATE INDEX fecundity__idx ON
    fecundity (
        stock_id
    ASC,
        collection_id
    ASC );

CREATE INDEX fecundity__idxv1 ON
    fecundity (
        still_valid
    ASC );

CREATE INDEX fecundity__idxv2 ON
    fecundity (
        stock_id
    ASC );

CREATE INDEX fecundity__idxv3 ON
    fecundity (
        collection_id
    ASC );

ALTER TABLE fecundity ADD CONSTRAINT fecundity_pk PRIMARY KEY ( fec_id );

ALTER TABLE fecundity
    ADD CONSTRAINT fecundity__un UNIQUE ( stock_id,
                                          collection_id,
                                          fec_start );

CREATE TABLE feedcode (
    feed_id        INTEGER NOT NULL,
    feed_short     VARCHAR2(10 CHAR) NOT NULL,
    feed_desc      VARCHAR2(35 CHAR) NOT NULL,
    manufacturer   VARCHAR2(50 CHAR) NOT NULL,
    created_by     VARCHAR2(32 CHAR) NOT NULL,
    created_date   DATE NOT NULL
);

COMMENT ON TABLE feedcode IS
    'Table describing the feed types used.';

COMMENT ON COLUMN feedcode.feed_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN feedcode.feed_short IS
    'Unigue, short description.';

COMMENT ON COLUMN feedcode.feed_desc IS
    'Long description for the type of feed.';

COMMENT ON COLUMN feedcode.manufacturer IS
    'Manufacturer of the feed.';

COMMENT ON COLUMN feedcode.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN feedcode.created_date IS
    'Date that the record was input.';

CREATE INDEX feedcode__idx ON
    feedcode (
        feed_short
    ASC );

CREATE INDEX feedcode__idxv1 ON
    feedcode (
        manufacturer
    ASC );

ALTER TABLE feedcode ADD CONSTRAINT feedcode_pk PRIMARY KEY ( feed_id );

ALTER TABLE feedcode ADD CONSTRAINT feedcode__un UNIQUE ( feed_short );

CREATE TABLE feeding (
    feeding_id          INTEGER NOT NULL,
    container_xref_id   INTEGER NOT NULL,
    feedmethod_id       INTEGER NOT NULL,
    feed_id             INTEGER NOT NULL,
    lot_number          VARCHAR2(40 CHAR),
    amount              NUMBER(7, 3) NOT NULL,
    unit_id             INTEGER NOT NULL,
    frequency           VARCHAR2(40 CHAR),
    comments            VARCHAR2(2000 CHAR),
    created_by          VARCHAR2(32 CHAR) NOT NULL,
    created_date        DATE NOT NULL
);

COMMENT ON TABLE feeding IS
    'Table that houses the information regarding the feed provided for a container of animals.';

COMMENT ON COLUMN feeding.feeding_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN feeding.container_xref_id IS
    'Links to the ContainersXRef table to identify which container the feed was provided to..';

COMMENT ON COLUMN feeding.feedmethod_id IS
    'Links to the FeedMethods table to describe hos the feed is delivered.';

COMMENT ON COLUMN feeding.feed_id IS
    'Links to the FeedCodes table to describe the type of feed used.';

COMMENT ON COLUMN feeding.lot_number IS
    'The lot number of the feed provided.';

COMMENT ON COLUMN feeding.amount IS
    'The amount of feed provided during the feeding.';

COMMENT ON COLUMN feeding.unit_id IS
    'The unit of measure for the feed provided.';

COMMENT ON COLUMN feeding.frequency IS
    'Description of the frequency of the feeding.';

COMMENT ON COLUMN feeding.comments IS
    'Comments regarding the data in this record.';

COMMENT ON COLUMN feeding.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN feeding.created_date IS
    'Date that the record was input.';

CREATE INDEX feeding__idx ON
    feeding (
        container_xref_id
    ASC,
        feed_id
    ASC );

CREATE INDEX feeding__idxv1 ON
    feeding (
        lot_number
    ASC );

CREATE INDEX feeding__idxv2 ON
    feeding (
        unit_id
    ASC );

CREATE INDEX feeding__idxv3 ON
    feeding (
        feed_id
    ASC );

CREATE INDEX feeding__idxv4 ON
    feeding (
        container_xref_id
    ASC );

ALTER TABLE feeding ADD CONSTRAINT feeding_pk PRIMARY KEY ( feeding_id );

ALTER TABLE feeding ADD CONSTRAINT feeding__un UNIQUE ( container_xref_id );

--  Contains the information on the method, for example manual or automated, on
--  how the feed is delivered.
CREATE TABLE feedmethod (
    feedmethod_id      INTEGER NOT NULL,
    feedmethod_short   VARCHAR2(4 CHAR) NOT NULL,
    feedmethod_desc    VARCHAR2(40 CHAR) NOT NULL,
    created_by         VARCHAR2(32 CHAR) NOT NULL,
    created_date       DATE NOT NULL
);

COMMENT ON TABLE feedmethod IS
    'Table that houses the fedding method codes and descriptions.';

COMMENT ON COLUMN feedmethod.feedmethod_id IS
    'System generated unique ID.';

COMMENT ON COLUMN feedmethod.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN feedmethod.created_date IS
    'Date that the record was input.';

CREATE INDEX feedmethod__idx ON
    feedmethod (
        feedmethod_short
    ASC );

ALTER TABLE feedmethod ADD CONSTRAINT feedmethod_pk PRIMARY KEY ( feedmethod_id );

ALTER TABLE feedmethod ADD CONSTRAINT feedmethod__un UNIQUE ( feedmethod_short );

CREATE TABLE "GROUP" (
    group_id        INTEGER NOT NULL,
    from_group_id   INTEGER,
    spec_id         INTEGER NOT NULL,
    stock_id        INTEGER NOT NULL,
    collection_id   INTEGER,
    still_valid     CHAR(1) NOT NULL,
    comments        VARCHAR2(2000 CHAR),
    created_by      VARCHAR2(32 CHAR) NOT NULL,
    created_date    DATE NOT NULL
);

COMMENT ON TABLE "GROUP" IS
    'Table that houses the information for a specific group of animals, including the original group which a new group originates from.'
    ;

COMMENT ON COLUMN "GROUP".group_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN "GROUP".from_group_id IS
    'The ID for the group from which this subgroup originated. Used to maintain the full history of groups and ultimately the individuals. A recursive foreign key which links back to the Groups table.'
    ;

COMMENT ON COLUMN "GROUP".spec_id IS
    'Links to the SpeciesCodes table to describe the species of the group. Currently defaulted to Atlantic Salmon.';

COMMENT ON COLUMN "GROUP".stock_id IS
    'Links to the StockCodes table to identify the stock that this group is from.';

COMMENT ON COLUMN "GROUP".collection_id IS
    'Links to the Collections table to describe what collection the group is made up of.';

COMMENT ON COLUMN "GROUP".still_valid IS
    'Boolean, Y or N, that indicates whether this record is still valid,  used to filter in the application and for reporting purposes.'
    ;

COMMENT ON COLUMN "GROUP".comments IS
    'Comments regarding the data in this record.';

COMMENT ON COLUMN "GROUP".created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN "GROUP".created_date IS
    'Date that the record was input.';

CREATE INDEX group__idx ON
    "GROUP" (
        spec_id
    ASC,
        stock_id
    ASC,
        collection_id
    ASC );

CREATE INDEX group__idxv1 ON
    "GROUP" (
        from_group_id
    ASC );

CREATE INDEX group__idxv2 ON
    "GROUP" (
        still_valid
    ASC );

CREATE INDEX group__idxv3 ON
    "GROUP" (
        spec_id
    ASC );

CREATE INDEX group__idxv4 ON
    "GROUP" (
        stock_id
    ASC );

CREATE INDEX group__idxv5 ON
    "GROUP" (
        collection_id
    ASC );

CREATE INDEX group__idxv6 ON
    "GROUP" (
        collection_id
    ASC );

ALTER TABLE "GROUP" ADD CONSTRAINT group_pk PRIMARY KEY ( group_id );

ALTER TABLE "GROUP" ADD CONSTRAINT group__un UNIQUE ( group_id,
                                                      from_group_id );

CREATE TABLE groupdet (
    group_det_id      INTEGER NOT NULL,
    ani_det_xref_id   INTEGER NOT NULL,
    ani_det_id        INTEGER NOT NULL,
    val               NUMBER(11, 5),
    ani_det_subj_id   INTEGER,
    qual_id           INTEGER NOT NULL,
    still_valid       CHAR(1) NOT NULL,
    comments          VARCHAR2(2000),
    created_by        VARCHAR2(32) NOT NULL,
    created_date      DATE NOT NULL
);

COMMENT ON TABLE groupdet IS
    'Table that houses details collected on a group during an event. For example the percentage of the group at a certain life history stage. Throughout the existence of a group, there may be many details collected on that group during different events and at different points in time.'
    ;

COMMENT ON COLUMN groupdet.group_det_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN groupdet.ani_det_xref_id IS
    'Links to the AniDetailsXRef table.';

COMMENT ON COLUMN groupdet.ani_det_id IS
    'Links to the AniDetCodes table to describe the type of measurement.';

COMMENT ON COLUMN groupdet.val IS
    'The value of the measurement if not a subjective observation.';

COMMENT ON COLUMN groupdet.ani_det_subj_id IS
    'Links to the AniDetSubjCodes to describe the subjective value.';

COMMENT ON COLUMN groupdet.qual_id IS
    'Links to the QualCodes table to describe the confidence in the recorded information.';

COMMENT ON COLUMN groupdet.still_valid IS
    'Boolean, Y or N, that indicates whether this record is still valid,  used to filter in the application and for reporting purposes.'
    ;

COMMENT ON COLUMN groupdet.comments IS
    'Comments regarding the data in this record.';

COMMENT ON COLUMN groupdet.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN groupdet.created_date IS
    'Date that the record was input.';

CREATE INDEX groupdet__idx ON
    groupdet (
        ani_det_xref_id
    ASC,
        ani_det_id
    ASC,
        ani_det_subj_id
    ASC );

CREATE INDEX groupdet__idxv1 ON
    groupdet (
        qual_id
    ASC );

CREATE INDEX groupdet__idxv2 ON
    groupdet (
        still_valid
    ASC );

CREATE INDEX groupdet__idxv3 ON
    groupdet (
        ani_det_xref_id
    ASC );

CREATE INDEX groupdet__idxv4 ON
    groupdet (
        ani_det_id
    ASC );

CREATE INDEX groupdet__idxv5 ON
    groupdet (
        ani_det_subj_id
    ASC );

ALTER TABLE groupdet
    ADD CONSTRAINT groupdet_ck_1 CHECK ( val IS NOT NULL
                                         OR ani_det_subj_id IS NOT NULL );

ALTER TABLE groupdet ADD CONSTRAINT groupdet_pk PRIMARY KEY ( group_det_id );

ALTER TABLE groupdet
    ADD CONSTRAINT groupdet__un UNIQUE ( ani_det_xref_id,
                                         ani_det_id,
                                         ani_det_subj_id );

CREATE TABLE heathunit (
    heath_unit_id      INTEGER NOT NULL,
    heath_unit_short   VARCHAR2(10 CHAR) NOT NULL,
    heath_unit_desc    VARCHAR2(35 CHAR) NOT NULL,
    manufacturer       VARCHAR2(35 CHAR) NOT NULL,
    inservice_date     DATE NOT NULL,
    serial_number      VARCHAR2(50 CHAR) NOT NULL,
    created_by         VARCHAR2(32 CHAR) NOT NULL,
    created_date       DATE NOT NULL
);

COMMENT ON TABLE heathunit IS
    'Table that uniquely identifies the heath units in use in the facilities.';

COMMENT ON COLUMN heathunit.heath_unit_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN heathunit.heath_unit_short IS
    'Unigue, short description.';

COMMENT ON COLUMN heathunit.heath_unit_desc IS
    'Longer description of the container.';

COMMENT ON COLUMN heathunit.manufacturer IS
    'Manufacturer of the unit.';

COMMENT ON COLUMN heathunit.inservice_date IS
    'Date that the unit was put in service.';

COMMENT ON COLUMN heathunit.serial_number IS
    'Serial number of the unit.';

COMMENT ON COLUMN heathunit.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN heathunit.created_date IS
    'Date that the record was input.';

CREATE INDEX heathunit__idx ON
    heathunit (
        heath_unit_short
    ASC,
        manufacturer
    ASC );

CREATE INDEX heathunit__idxv1 ON
    heathunit (
        heath_unit_short
    ASC );

CREATE INDEX heathunit__idxv2 ON
    heathunit (
        manufacturer
    ASC );

ALTER TABLE heathunit ADD CONSTRAINT heathunit_pk PRIMARY KEY ( heath_unit_id );

ALTER TABLE heathunit ADD CONSTRAINT heathunit__un UNIQUE ( heath_unit_short );

CREATE TABLE heathunitdet (
    heath_unit_det_id   INTEGER NOT NULL,
    heath_unit_id       INTEGER NOT NULL,
    cont_det_id         INTEGER NOT NULL,
    val                 NUMBER(11, 5),
    cont_det_subj_id    INTEGER,
    heath_det_start     DATE NOT NULL,
    heath_det_end       DATE,
    still_valid         CHAR(1) NOT NULL,
    comments            VARCHAR2(2000 CHAR),
    created_by          VARCHAR2(32 CHAR) NOT NULL,
    created_date        DATE NOT NULL
);

COMMENT ON TABLE heathunitdet IS
    'Table that houses the various details for a heath unit.';

COMMENT ON COLUMN heathunitdet.heath_unit_det_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN heathunitdet.heath_unit_id IS
    'Links to the HeathUnits table.';

COMMENT ON COLUMN heathunitdet.cont_det_id IS
    'Links to the ContainerDetCodes table to describe the type of detail recorded.';

COMMENT ON COLUMN heathunitdet.val IS
    'The value of the measurement if not a subjective observation.';

COMMENT ON COLUMN heathunitdet.cont_det_subj_id IS
    'Links to the ContDetSubjCodes table to describe the observation.';

COMMENT ON COLUMN heathunitdet.heath_det_start IS
    'The date that the detail was recorded, mandatory.';

COMMENT ON COLUMN heathunitdet.heath_det_end IS
    'The last date which the detail is still valid.';

COMMENT ON COLUMN heathunitdet.still_valid IS
    'Boolean, Y or N, that indicates whether this record is still valid,  used to filter in the application and for reporting purposes.'
    ;

COMMENT ON COLUMN heathunitdet.comments IS
    'Comments regarding the data in this record.';

COMMENT ON COLUMN heathunitdet.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN heathunitdet.created_date IS
    'Date that the record was input.';

CREATE INDEX heathunitdet__idx ON
    heathunitdet (
        heath_unit_id
    ASC,
        cont_det_id
    ASC,
        cont_det_subj_id
    ASC );

CREATE INDEX heathunitdet__idxv1 ON
    heathunitdet (
        still_valid
    ASC );

CREATE INDEX heathunitdet__idxv2 ON
    heathunitdet (
        heath_unit_id
    ASC );

CREATE INDEX heathunitdet__idxv3 ON
    heathunitdet (
        cont_det_id
    ASC );

CREATE INDEX heathunitdet__idxv4 ON
    heathunitdet (
        cont_det_subj_id
    ASC );

ALTER TABLE heathunitdet
    ADD CONSTRAINT heathunitdet_ck_1 CHECK ( val IS NOT NULL
                                             OR cont_det_subj_id IS NOT NULL );

ALTER TABLE heathunitdet ADD CONSTRAINT heathunitdet_pk PRIMARY KEY ( heath_unit_det_id );

ALTER TABLE heathunitdet
    ADD CONSTRAINT heathunitdet__un UNIQUE ( heath_unit_id,
                                             cont_det_id,
                                             cont_det_subj_id,
                                             heath_det_start );

CREATE TABLE image (
    image_id            INTEGER NOT NULL,
    img_id              INTEGER NOT NULL,
    location_id         INTEGER,
    count_det_id        INTEGER,
    group_det_id        INTEGER,
    samp_det_id         INTEGER,
    indiv_det_id        INTEGER,
    spawn_detail_id     INTEGER,
    tank_det_id         INTEGER,
    heath_unit_det_id   INTEGER,
    drawer_id           INTEGER,
    trough_det_id       INTEGER,
    tray_det_id         INTEGER,
    cup_det_id          INTEGER,
    image               BLOB NOT NULL,
    comments            VARCHAR2(2000 CHAR),
    created_by          VARCHAR2(32 CHAR) NOT NULL,
    created_date        DATE NOT NULL
);

COMMENT ON TABLE image IS
    'Table that houses digital images. These images may be associated with a number of things, for example a location, group, or individual.'
    ;

COMMENT ON COLUMN image.image_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN image.img_id IS
    'Links to the ImageCodes table to describe the type of image.';

COMMENT ON COLUMN image.location_id IS
    'Links to the Locations table if the image is of a location.';

COMMENT ON COLUMN image.count_det_id IS
    'Links to the CountDets table if the image is of a count, for example eggs which were counted.';

COMMENT ON COLUMN image.group_det_id IS
    'Links to the GroupDets table if the image is of a group detail, for example an indication of percentage of fish within a group which are of a specific life history stage.'
    ;

COMMENT ON COLUMN image.samp_det_id IS
    'Links to the SampleDets table if the image is related a fish sampled in the field.';

COMMENT ON COLUMN image.indiv_det_id IS
    'Links to the Individuals table if the image is of an individual fish''s detail information, for example a scar.';

COMMENT ON COLUMN image.spawn_detail_id IS
    'Links to the SpawnDets table if the image is related to spawning, for example milt.';

COMMENT ON COLUMN image.tank_det_id IS
    'Links to the TankDets table for images of a tank, for example of an enrichment added.';

COMMENT ON COLUMN image.heath_unit_det_id IS
    'Links to the HeathUnitDets table if the image taken is specific to a heath unit.';

COMMENT ON COLUMN image.drawer_id IS
    'Links to the Drawers table if the image is of a drawer of a heath unit.';

COMMENT ON COLUMN image.trough_det_id IS
    'Links to the TroughDets table for images taken of a trough.';

COMMENT ON COLUMN image.tray_det_id IS
    'Links to the TrayDets table.';

COMMENT ON COLUMN image.cup_det_id IS
    'Links to the CupDets table.';

COMMENT ON COLUMN image.image IS
    'The digital iimage.';

COMMENT ON COLUMN image.comments IS
    'Comments regarding the data in this record.';

COMMENT ON COLUMN image.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN image.created_date IS
    'Date that the record was input.';

CREATE INDEX image__idx ON
    image (
        location_id
    ASC,
        count_det_id
    ASC,
        group_det_id
    ASC,
        samp_det_id
    ASC,
        indiv_det_id
    ASC,
        spawn_detail_id
    ASC,
        tank_det_id
    ASC,
        heath_unit_det_id
    ASC,
        drawer_id
    ASC,
        trough_det_id
    ASC,
        tray_det_id
    ASC,
        cup_det_id
    ASC );

CREATE INDEX image__idxv1 ON
    image (
        img_id
    ASC );

CREATE INDEX image__idxv2 ON
    image (
        location_id
    ASC );

CREATE INDEX image__idxv3 ON
    image (
        count_det_id
    ASC );

CREATE INDEX image__idxv4 ON
    image (
        group_det_id
    ASC );

CREATE INDEX image__idxv5 ON
    image (
        samp_det_id
    ASC );

CREATE INDEX image__idxv6 ON
    image (
        indiv_det_id
    ASC );

CREATE INDEX image__idxv7 ON
    image (
        indiv_det_id
    ASC );

CREATE INDEX image__idxv8 ON
    image (
        spawn_detail_id
    ASC );

CREATE INDEX image__idxv9 ON
    image (
        tank_det_id
    ASC );

CREATE INDEX image__idxv10 ON
    image (
        heath_unit_det_id
    ASC );

CREATE INDEX image__idxv11 ON
    image (
        drawer_id
    ASC );

CREATE INDEX image__idxv12 ON
    image (
        trough_det_id
    ASC );

CREATE INDEX image__idxv13 ON
    image (
        tray_det_id
    ASC );

CREATE INDEX image__idxv14 ON
    image (
        cup_det_id
    ASC );

ALTER TABLE image
    ADD CONSTRAINT image_ck_1 CHECK ( location_id IS NOT NULL
                                      OR count_det_id IS NOT NULL
                                      OR group_det_id IS NOT NULL
                                      OR samp_det_id IS NOT NULL
                                      OR indiv_det_id IS NOT NULL
                                      OR spawn_detail_id IS NOT NULL
                                      OR tank_det_id IS NOT NULL
                                      OR heath_unit_det_id IS NOT NULL
                                      OR drawer_id IS NOT NULL
                                      OR trough_det_id IS NOT NULL
                                      OR tray_det_id IS NOT NULL
                                      OR cup_det_id IS NOT NULL );

ALTER TABLE image ADD CONSTRAINT image_pk PRIMARY KEY ( image_id );

ALTER TABLE image
    ADD CONSTRAINT image__un UNIQUE ( location_id,
                                      count_det_id,
                                      group_det_id,
                                      samp_det_id,
                                      indiv_det_id,
                                      spawn_detail_id,
                                      tank_det_id,
                                      heath_unit_det_id,
                                      drawer_id,
                                      trough_det_id,
                                      tray_det_id,
                                      cup_det_id,
                                      img_id );

CREATE TABLE imagecode (
    img_id         INTEGER NOT NULL,
    img_short      VARCHAR2(10 CHAR) NOT NULL,
    img_desc       VARCHAR2(35 CHAR) NOT NULL,
    created_by     VARCHAR2(32 CHAR) NOT NULL,
    created_date   DATE NOT NULL
);

COMMENT ON TABLE imagecode IS
    'Table that houses the descriptions the types of images which might be collected and stored.';

COMMENT ON COLUMN imagecode.img_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN imagecode.img_short IS
    'Unigue, short description.';

COMMENT ON COLUMN imagecode.img_desc IS
    'The long description of the image type.';

COMMENT ON COLUMN imagecode.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN imagecode.created_date IS
    'Date that the record was input.';

CREATE INDEX imagecode__idx ON
    imagecode (
        img_short
    ASC );

ALTER TABLE imagecode ADD CONSTRAINT imagecode_pk PRIMARY KEY ( img_id );

ALTER TABLE imagecode ADD CONSTRAINT imagecode__un UNIQUE ( img_short );

CREATE TABLE individual (
    indiv_id        INTEGER NOT NULL,
    group_id        INTEGER,
    spec_id         INTEGER NOT NULL,
    stock_id        INTEGER NOT NULL,
    collection_id   INTEGER,
    ufid            VARCHAR2(50 CHAR),
    pit_tag         VARCHAR2(50 CHAR),
    still_valid     CHAR(1) NOT NULL,
    comments        VARCHAR2(2000 CHAR),
    created_by      VARCHAR2(32 CHAR) NOT NULL,
    created_date    DATE NOT NULL
);

COMMENT ON TABLE individual IS
    'Table that houses the information for a specific individual.';

COMMENT ON COLUMN individual.indiv_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN individual.group_id IS
    'The group the individual was last part of, if applicable. ';

COMMENT ON COLUMN individual.spec_id IS
    'Links to the SpeciesCodes table. Currently defaulted to Atlantic Salmon.';

COMMENT ON COLUMN individual.stock_id IS
    'Links to the StockCodes table to identify the stock that this individual belongs to.';

COMMENT ON COLUMN individual.collection_id IS
    'Links to the Collections table to describe the collection this individual is from.';

COMMENT ON COLUMN individual.ufid IS
    'Unique Fish ID supplied by ABL.';

COMMENT ON COLUMN individual.pit_tag IS
    'The PIT tag identifier for this animal.';

COMMENT ON COLUMN individual.still_valid IS
    'Boolean, Y or N, that indicates whether this record is still valid,  used to filter in the application and for reporting purposes.'
    ;

COMMENT ON COLUMN individual.comments IS
    'Comments regarding the data in this record.';

COMMENT ON COLUMN individual.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN individual.created_date IS
    'Date that the record was input.';

CREATE INDEX individual__idx ON
    individual (
        group_id
    ASC,
        spec_id
    ASC,
        stock_id
    ASC,
        collection_id
    ASC );

CREATE INDEX individual__idxv1 ON
    individual (
        still_valid
    ASC );

CREATE INDEX individual__idxv2 ON
    individual (
        group_id
    ASC );

CREATE INDEX individual__idxv3 ON
    individual (
        spec_id
    ASC );

CREATE INDEX individual__idxv4 ON
    individual (
        stock_id
    ASC );

CREATE INDEX individual__idxv5 ON
    individual (
        collection_id
    ASC );

ALTER TABLE individual ADD CONSTRAINT individual_pk PRIMARY KEY ( indiv_id );

ALTER TABLE individual ADD CONSTRAINT individual__pit_un UNIQUE ( pit_tag );

ALTER TABLE individual ADD CONSTRAINT individual__ufid_un UNIQUE ( ufid );

CREATE TABLE individualdet (
    indiv_det_id      INTEGER NOT NULL,
    ani_det_xref_id   INTEGER NOT NULL,
    ani_det_id        INTEGER NOT NULL,
    val               NUMBER(11, 5),
    ani_det_subj_id   INTEGER,
    qual_id           INTEGER NOT NULL,
    still_valid       CHAR(1) NOT NULL,
    comments          VARCHAR2(2000),
    created_by        VARCHAR2(32) NOT NULL,
    created_date      DATE NOT NULL
);

COMMENT ON TABLE individualdet IS
    'Table that houses the detailed measurements or observations collected on an individual during a handling event. For example the length of animal over time will be housed here. Throughout the existence of an individual, there may be many details collected on that animal during different events and at different points in time. When an individual is handled there may, or may not, be a location involved. For example during spawning the location is not relevant, however if the animal is released the location must be recorded.'
    ;

COMMENT ON COLUMN individualdet.indiv_det_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN individualdet.ani_det_xref_id IS
    'Links to the AniDetailsXRef table.';

COMMENT ON COLUMN individualdet.ani_det_id IS
    'Links to the AnimalDetCodes table to identify the type of measurement or observation being recorded.';

COMMENT ON COLUMN individualdet.val IS
    'The value of the measurement if not a subjective observation.';

COMMENT ON COLUMN individualdet.ani_det_subj_id IS
    'Links to the AniDetSubjCodes table to indicate the observation recorded.';

COMMENT ON COLUMN individualdet.still_valid IS
    'Boolean, Y or N, that indicates whether this record is still valid. For example if a fish is incorrectly sexed at some point during it''s life, this would be made N when the correct sex has been recorded.'
    ;

COMMENT ON COLUMN individualdet.comments IS
    'Comments regarding the data in this record.';

COMMENT ON COLUMN individualdet.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN individualdet.created_date IS
    'Date that the record was input.';

CREATE INDEX individualdet__idx ON
    individualdet (
        ani_det_xref_id
    ASC,
        ani_det_id
    ASC,
        ani_det_subj_id
    ASC );

CREATE INDEX individualdet__idxv1 ON
    individualdet (
        still_valid
    ASC );

CREATE INDEX individualdet__idxv2 ON
    individualdet (
        qual_id
    ASC );

CREATE INDEX individualdet__idxv3 ON
    individualdet (
        ani_det_xref_id
    ASC );

CREATE INDEX individualdet__idxv4 ON
    individualdet (
        ani_det_id
    ASC );

CREATE INDEX individualdets__idxv5 ON
    individualdet (
        ani_det_subj_id
    ASC );

ALTER TABLE individualdet
    ADD CONSTRAINT individualdet_ck_1 CHECK ( val IS NOT NULL
                                              OR ani_det_subj_id IS NOT NULL );

ALTER TABLE individualdet ADD CONSTRAINT individualdet_pk PRIMARY KEY ( indiv_det_id );

ALTER TABLE individualdet
    ADD CONSTRAINT individualdet__un UNIQUE ( ani_det_xref_id,
                                              ani_det_id,
                                              ani_det_subj_id );

CREATE TABLE indtreatcode (
    ind_treat_id       INTEGER NOT NULL,
    ind_treat_short    VARCHAR2(10 CHAR) NOT NULL,
    ind_treat_desc     VARCHAR2(300 CHAR) NOT NULL,
    ind_rec_dosage     VARCHAR2(400 CHAR) NOT NULL,
    ind_manufacturer   VARCHAR2(50 CHAR) NOT NULL,
    created_by         VARCHAR2(32 CHAR) NOT NULL,
    created_date       DATE NOT NULL
);

COMMENT ON TABLE indtreatcode IS
    'Table describing the various types of treatments which may be performed on an individual animal.';

COMMENT ON COLUMN indtreatcode.ind_treat_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN indtreatcode.ind_treat_short IS
    'Unigue, short description.';

COMMENT ON COLUMN indtreatcode.ind_treat_desc IS
    'Long description of the type of treatment.';

COMMENT ON COLUMN indtreatcode.ind_rec_dosage IS
    'Recommended dosage for the product per manufacturer''s guidelines.';

COMMENT ON COLUMN indtreatcode.ind_manufacturer IS
    'The manufacturer of the treatment product.';

COMMENT ON COLUMN indtreatcode.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN indtreatcode.created_date IS
    'Date that the record was input.';

CREATE INDEX indtreatcode__idx ON
    indtreatcode (
        ind_treat_short
    ASC,
        ind_manufacturer
    ASC );

ALTER TABLE indtreatcode ADD CONSTRAINT indtreatcode_pk PRIMARY KEY ( ind_treat_id );

ALTER TABLE indtreatcode ADD CONSTRAINT indtreatcode__un UNIQUE ( ind_treat_short );

CREATE TABLE indtreatment (
    ind_treatment_id   INTEGER NOT NULL,
    ind_treat_id       INTEGER NOT NULL,
    lot_number         VARCHAR2(30 CHAR) NOT NULL,
    dose               NUMBER(7, 3) NOT NULL,
    treat_start_time   NUMBER(4),
    treat_end_time     NUMBER(4),
    comments           VARCHAR2(2000 CHAR),
    created_by         VARCHAR2(32 CHAR) NOT NULL,
    created_date       DATE NOT NULL
);

ALTER TABLE indtreatment ADD CHECK ( treat_start_time BETWEEN 1 AND 2400 );

COMMENT ON TABLE indtreatment IS
    'Table containing information on various health treatments for an individual animal.';

COMMENT ON COLUMN indtreatment.ind_treatment_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN indtreatment.ind_treat_id IS
    'Links to the IndTreatCodes table which describes the type of treament performed.';

COMMENT ON COLUMN indtreatment.lot_number IS
    'The lot number of the product used.';

COMMENT ON COLUMN indtreatment.dose IS
    'The dosage used on the individual in ????? what unit??';

COMMENT ON COLUMN indtreatment.treat_start_time IS
    'The start time of the treatment if required, valid entires are 1 to 2400. Time is in local time.';

COMMENT ON COLUMN indtreatment.treat_end_time IS
    'The end time for the treatment, local time. Valid entries are 1 to 2400.';

COMMENT ON COLUMN indtreatment.comments IS
    'Comments regarding the data in this record.';

COMMENT ON COLUMN indtreatment.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN indtreatment.created_date IS
    'Date that the record was input.';

CREATE INDEX indtreatment__idx ON
    indtreatment (
        ind_treat_id
    ASC );

CREATE INDEX indtreatment__idxv1 ON
    indtreatment (
        lot_number
    ASC );

ALTER TABLE indtreatment ADD CONSTRAINT indtreatment_pk PRIMARY KEY ( ind_treatment_id );

ALTER TABLE indtreatment ADD CONSTRAINT indtreatment__un UNIQUE ( ind_treatment_id,
                                                                  ind_treat_id );

CREATE TABLE instdetcode (
    inst_det_id      INTEGER NOT NULL,
    inst_det_short   VARCHAR2(10 CHAR) NOT NULL,
    inst_det_desc    VARCHAR2(300 CHAR) NOT NULL,
    created_by       VARCHAR2(32 CHAR) NOT NULL,
    created_date     DATE NOT NULL
);

COMMENT ON TABLE instdetcode IS
    'Table that houses the descirtpions of the types of details recorded for the instruments used to collect environmental conditions.'
    ;

COMMENT ON COLUMN instdetcode.inst_det_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN instdetcode.inst_det_short IS
    'Unigue, short description.';

COMMENT ON COLUMN instdetcode.inst_det_desc IS
    'Long description of the type of instrument detail.';

COMMENT ON COLUMN instdetcode.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN instdetcode.created_date IS
    'Date that the record was input.';

CREATE INDEX instdetcode__idx ON
    instdetcode (
        inst_det_short
    ASC );

ALTER TABLE instdetcode ADD CONSTRAINT instdetcode_pk PRIMARY KEY ( inst_det_id );

ALTER TABLE instdetcode ADD CONSTRAINT instdetcode__un UNIQUE ( inst_det_short );

CREATE TABLE instrument (
    instrum_id      INTEGER NOT NULL,
    inst_id         INTEGER NOT NULL,
    serial_number   VARCHAR2(50 CHAR),
    comments        VARCHAR2(2000 CHAR),
    created_by      VARCHAR2(32 CHAR) NOT NULL,
    created_date    DATE NOT NULL
);

COMMENT ON TABLE instrument IS
    'Table that houses information on the instrument used, if applicable, for the collection of the environmental conditions of a location.'
    ;

COMMENT ON COLUMN instrument.instrum_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN instrument.inst_id IS
    'Links to the InstrumentCodes table to describe the type of instrument.';

COMMENT ON COLUMN instrument.serial_number IS
    'Serial number of the instrument used.';

COMMENT ON COLUMN instrument.comments IS
    'Comments regarding the data in this record.';

COMMENT ON COLUMN instrument.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN instrument.created_date IS
    'Date that the record was input.';

CREATE INDEX instrument__idx ON
    instrument (
        inst_id
    ASC );

ALTER TABLE instrument ADD CONSTRAINT instrument_pk PRIMARY KEY ( instrum_id );

ALTER TABLE instrument ADD CONSTRAINT instrument__un UNIQUE ( inst_id,
                                                              serial_number );

ALTER TABLE instrument ADD CONSTRAINT instrument_serial_num_un UNIQUE ( serial_number );

CREATE TABLE instrumentcode (
    inst_id        INTEGER NOT NULL,
    inst_short     VARCHAR2(5 CHAR) NOT NULL,
    inst_desc      VARCHAR2(100 CHAR) NOT NULL,
    created_by     VARCHAR2(32 CHAR) NOT NULL,
    created_date   DATE NOT NULL
);

COMMENT ON TABLE instrumentcode IS
    'Table that houses the descriptions for the various instruments used to collect environmental conditions.';

COMMENT ON COLUMN instrumentcode.inst_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN instrumentcode.inst_short IS
    'Unigue, short description.';

COMMENT ON COLUMN instrumentcode.inst_desc IS
    'Long description of the type of instrument.';

COMMENT ON COLUMN instrumentcode.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN instrumentcode.created_date IS
    'Date that the record was input.';

CREATE INDEX instrumentcode__idx ON
    instrumentcode (
        inst_short
    ASC );

ALTER TABLE instrumentcode ADD CONSTRAINT instrumentcode_pk PRIMARY KEY ( inst_id );

ALTER TABLE instrumentcode ADD CONSTRAINT instrumentcode__un UNIQUE ( inst_short );

CREATE TABLE instrumentdet (
    instrum_det_id      INTEGER NOT NULL,
    instrum_id          INTEGER NOT NULL,
    inst_det_id         INTEGER NOT NULL,
    val                 NUMBER(11, 5) NOT NULL,
    instrum_det_start   DATE NOT NULL,
    instrum_det_end     DATE,
    still_valid         CHAR(1) NOT NULL,
    comments            VARCHAR2(2000 CHAR),
    created_by          VARCHAR2(32 CHAR) NOT NULL,
    created_date        DATE NOT NULL
);

COMMENT ON TABLE instrumentdet IS
    'Table that houses details on the instrument.';

COMMENT ON COLUMN instrumentdet.instrum_det_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN instrumentdet.instrum_id IS
    'Links to the Instruments table.';

COMMENT ON COLUMN instrumentdet.inst_det_id IS
    'Links to the InstDetCodes table to describe the type of information.';

COMMENT ON COLUMN instrumentdet.val IS
    'The value of the measurement.';

COMMENT ON COLUMN instrumentdet.instrum_det_start IS
    'Date of the change to the instrument.';

COMMENT ON COLUMN instrumentdet.instrum_det_end IS
    'The last date which the detail is still valid.';

COMMENT ON COLUMN instrumentdet.still_valid IS
    'Boolean, Y or N, that indicates whether this record is still valid,  used to filter in the application and for reporting purposes.'
    ;

COMMENT ON COLUMN instrumentdet.comments IS
    'Comments regarding the data in this record.';

COMMENT ON COLUMN instrumentdet.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN instrumentdet.created_date IS
    'Date that the record was input.';

CREATE INDEX instrumentdet__idx ON
    instrumentdet (
        instrum_id
    ASC,
        inst_det_id
    ASC );

CREATE INDEX instrumentdet__idxv1 ON
    instrumentdet (
        still_valid
    ASC );

CREATE INDEX instrumentdet__idxv2 ON
    instrumentdet (
        instrum_id
    ASC );

CREATE INDEX instrumentdet__idxv3 ON
    instrumentdet (
        inst_det_id
    ASC );

ALTER TABLE instrumentdet ADD CONSTRAINT instrumentdet_pk PRIMARY KEY ( instrum_det_id );

ALTER TABLE instrumentdet
    ADD CONSTRAINT instrumentdet__un UNIQUE ( instrum_id,
                                              inst_det_id,
                                              instrum_det_start );

--  The locations table is used to house and describe vaiour possible locations
--  within a facility.
CREATE TABLE location (
    location_id     INTEGER NOT NULL,
    event_id        INTEGER NOT NULL,
    loc_id          INTEGER NOT NULL,
    river_id        INTEGER,
    trib_id         INTEGER,
    subriver_id     INTEGER,
    rel_site_id     INTEGER,
    latitude        NUMBER(7, 5),
    longitude       NUMBER(8, 5),
    location_date   DATE,
    location_time   NUMBER(4),
    comments        VARCHAR2(2000 CHAR),
    created_by      VARCHAR2(32 CHAR) NOT NULL,
    created_date    DATE NOT NULL
);

COMMENT ON TABLE location IS
    'Table that houses the information that describes where the event took place. An event may have multiple locations associated with it, for example releases may be  in various locales. If the location is a container which houses a fish or group of them the ContainersXRef table will assist in identifying the specific container.'
    ;

COMMENT ON COLUMN location.location_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN location.event_id IS
    'Links to the Events table for the information for the work performed at this location.';

COMMENT ON COLUMN location.loc_id IS
    'Links to the LocationCodes table for the description of the type of location.';

COMMENT ON COLUMN location.river_id IS
    'Links to the RiverCodes table for the description of the river system.';

COMMENT ON COLUMN location.trib_id IS
    'Links to the Tributaries table for information on the tributary.';

COMMENT ON COLUMN location.subriver_id IS
    'Links to the SubRiverCodes table for information on the subriver that the work was done on.';

COMMENT ON COLUMN location.rel_site_id IS
    'Links to the ReleaseSiteCodes table for information on the release site.';

COMMENT ON COLUMN location.latitude IS
    'Latitude of the location in decimal degrees.';

COMMENT ON COLUMN location.longitude IS
    'The longitude for the work in decimal degrees.';

COMMENT ON COLUMN location.location_date IS
    'The date at which the work was performed at the location populated if the event takes place over multiple days..';

COMMENT ON COLUMN location.location_time IS
    'The time of the event at this location, valid entires are 1 to 2400. Time is local time.';

COMMENT ON COLUMN location.comments IS
    'Comments regarding the data in this record.';

COMMENT ON COLUMN location.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN location.created_date IS
    'Date that the record was input.';

CREATE INDEX location__idx ON
    location (
        event_id
    ASC,
        loc_id
    ASC,
        river_id
    ASC,
        trib_id
    ASC,
        subriver_id
    ASC,
        rel_site_id
    ASC );

CREATE INDEX location__idxv1 ON
    location (
        event_id
    ASC );

CREATE INDEX location__idxv2 ON
    location (
        loc_id
    ASC );

CREATE INDEX location__idxv3 ON
    location (
        river_id
    ASC );

CREATE INDEX location__idxv4 ON
    location (
        trib_id
    ASC );

CREATE INDEX location__idxv5 ON
    location (
        subriver_id
    ASC );

CREATE INDEX location__idxv6 ON
    location (
        rel_site_id
    ASC );

ALTER TABLE location
    ADD CONSTRAINT location_ck_1 CHECK ( river_id IS NOT NULL
                                         OR trib_id IS NOT NULL
                                         OR subriver_id IS NOT NULL );

ALTER TABLE location ADD CONSTRAINT location_pk PRIMARY KEY ( location_id );

ALTER TABLE location
    ADD CONSTRAINT location__un UNIQUE ( event_id,
                                         loc_id,
                                         river_id,
                                         trib_id,
                                         subriver_id,
                                         rel_site_id,
                                         latitude,
                                         longitude,
                                         location_date,
                                         location_time );

CREATE TABLE loccode (
    loc_id         INTEGER NOT NULL,
    loc_short      VARCHAR2(10 CHAR) NOT NULL,
    loc_desc       VARCHAR2(40 CHAR) NOT NULL,
    created_by     VARCHAR2(32 CHAR) NOT NULL,
    created_date   DATE NOT NULL
);

COMMENT ON TABLE loccode IS
    'Table which houses the descriptions of the types of locations.';

COMMENT ON COLUMN loccode.loc_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN loccode.loc_short IS
    'Unigue, short description.';

COMMENT ON COLUMN loccode.loc_desc IS
    'Long description of the type of location.';

COMMENT ON COLUMN loccode.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN loccode.created_date IS
    'Date that the record was input.';

CREATE INDEX loccode__idx ON
    loccode (
        loc_short
    ASC );

ALTER TABLE loccode ADD CONSTRAINT loccode_pk PRIMARY KEY ( loc_id );

ALTER TABLE loccode ADD CONSTRAINT loccode__un UNIQUE ( loc_short );

CREATE TABLE matingplan (
    matingplan_id   INTEGER NOT NULL,
    event_id        INTEGER NOT NULL,
    matingplan      BLOB NOT NULL,
    stock_id        INTEGER,
    comments        VARCHAR2(2000 CHAR),
    created_by      VARCHAR2(32 CHAR) NOT NULL,
    created_date    DATE NOT NULL
);

COMMENT ON TABLE matingplan IS
    'Table that houses the completed Mating Plan for the spawning.';

COMMENT ON COLUMN matingplan.matingplan_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN matingplan.event_id IS
    'Links to the EVent table for the spawning event.';

COMMENT ON COLUMN matingplan.matingplan IS
    'The completed Mating Plan spreadsheet used during the spawning activity.';

COMMENT ON COLUMN matingplan.stock_id IS
    'Stock that the mating plan is for.';

COMMENT ON COLUMN matingplan.comments IS
    'Comments regarding the data in this record.';

COMMENT ON COLUMN matingplan.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN matingplan.created_date IS
    'Date that the record was input.';

CREATE INDEX matingplan__idx ON
    matingplan (
        event_id
    ASC );

ALTER TABLE matingplan ADD CONSTRAINT matingplan_pk PRIMARY KEY ( matingplan_id );

ALTER TABLE matingplan
    ADD CONSTRAINT matingplan__un UNIQUE ( event_id,
                                           matingplan_id,
                                           stock_id );

CREATE TABLE organization (
    org_id         INTEGER NOT NULL,
    org_short      VARCHAR2(10 CHAR) NOT NULL,
    org_desc       VARCHAR2(50 CHAR) NOT NULL,
    created_by     VARCHAR2(32 CHAR) NOT NULL,
    created_date   DATE NOT NULL
);

COMMENT ON TABLE organization IS
    'Table which houses the descriptions for the organization which the program is associated with.';

COMMENT ON COLUMN organization.org_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN organization.org_short IS
    'Unigue, short description.';

COMMENT ON COLUMN organization.org_desc IS
    'Long description of the organization.';

COMMENT ON COLUMN organization.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN organization.created_date IS
    'Date that the record was input.';

CREATE INDEX organization__idx ON
    organization (
        org_short
    ASC );

ALTER TABLE organization ADD CONSTRAINT organization_pk PRIMARY KEY ( org_id );

ALTER TABLE organization ADD CONSTRAINT organization__un UNIQUE ( org_short );

CREATE TABLE pairing (
    pair_id        INTEGER NOT NULL,
    pair_start     DATE NOT NULL,
    pair_end       DATE,
    dam            VARCHAR2(50 CHAR) NOT NULL,
    still_valid    CHAR(1) NOT NULL,
    comments       VARCHAR2(2000 CHAR),
    created_by     VARCHAR2(32 CHAR) NOT NULL,
    created_date   DATE NOT NULL
);

COMMENT ON TABLE pairing IS
    'Table that houses information on possible pairings for spawnings.';

COMMENT ON COLUMN pairing.pair_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN pairing.pair_start IS
    'The date which the planned pairing was created.';

COMMENT ON COLUMN pairing.pair_end IS
    'The date at which the planned pairing became no longer a valid one.';

COMMENT ON COLUMN pairing.dam IS
    'Dam of the pair, links to the Unique Fish ID, UFID field in Individuals table.';

COMMENT ON COLUMN pairing.still_valid IS
    'Boolean, Y or N, that indicates whether this record is still valid,  used to filter in the application and for reporting purposes.'
    ;

COMMENT ON COLUMN pairing.comments IS
    'Comments regarding the data in this record.';

COMMENT ON COLUMN pairing.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN pairing.created_date IS
    'Date that the record was input.';

CREATE INDEX pairing__idxv1 ON
    pairing (
        dam
    ASC );

CREATE INDEX pairing__idxv2 ON
    pairing (
        still_valid
    ASC );

ALTER TABLE pairing ADD CONSTRAINT pairing_pk PRIMARY KEY ( pair_id );

ALTER TABLE pairing ADD CONSTRAINT pairing__un UNIQUE ( dam,
                                                        pair_start );

CREATE TABLE personnelcode (
    per_id           INTEGER NOT NULL,
    per_first_name   VARCHAR2(35 CHAR) NOT NULL,
    per_last_name    VARCHAR2(35 CHAR) NOT NULL,
    still_valid      CHAR(1) NOT NULL,
    created_by       VARCHAR2(32 CHAR) NOT NULL,
    created_date     DATE NOT NULL
);

COMMENT ON TABLE personnelcode IS
    'Table that houses the personnel which may be involved performing various tasks as part of a team, or as the team lead or individual for an event.'
    ;

COMMENT ON COLUMN personnelcode.per_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN personnelcode.per_first_name IS
    'First name of the person performing the task.';

COMMENT ON COLUMN personnelcode.per_last_name IS
    'Last name of the person performing the task.';

COMMENT ON COLUMN personnelcode.still_valid IS
    'Boolean, Y or N, that indicates whether this record is still valid,  used to filter in the application and for reporting purposes.'
    ;

COMMENT ON COLUMN personnelcode.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN personnelcode.created_date IS
    'Date that the record was input.';

CREATE INDEX personnelcode__idx ON
    personnelcode (
        per_first_name
    ASC,
        per_last_name
    ASC );

CREATE INDEX personnelcode__idxv1 ON
    personnelcode (
        still_valid
    ASC );

ALTER TABLE personnelcode ADD CONSTRAINT personnelcode_pk PRIMARY KEY ( per_id );

ALTER TABLE personnelcode ADD CONSTRAINT personnelcode__un UNIQUE ( per_first_name,
                                                                    per_last_name );

CREATE TABLE prioritycode (
    priority_id      INTEGER NOT NULL,
    priority_short   VARCHAR2(2 CHAR) NOT NULL,
    priority_desc    VARCHAR2(35 CHAR) NOT NULL,
    created_by       VARCHAR2(32 CHAR) NOT NULL,
    created_date     DATE NOT NULL
);

COMMENT ON TABLE prioritycode IS
    'Table that houses the priority codes and descriptions.';

COMMENT ON COLUMN prioritycode.priority_id IS
    'System generated primary key.';

COMMENT ON COLUMN prioritycode.priority_short IS
    'Short descriptor for the priority.';

COMMENT ON COLUMN prioritycode.priority_desc IS
    'Long description of the priority.';

COMMENT ON COLUMN prioritycode.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN prioritycode.created_date IS
    'Date that the record was input.';

CREATE INDEX prioritycode__idx ON
    prioritycode (
        priority_short
    ASC );

ALTER TABLE prioritycode ADD CONSTRAINT prioritycode_pk PRIMARY KEY ( priority_id );

ALTER TABLE prioritycode ADD CONSTRAINT prioritycode__un UNIQUE ( priority_short );

CREATE TABLE progauthority (
    prog_auth_id           INTEGER NOT NULL,
    prog_auth_last_name    VARCHAR2(35 CHAR) NOT NULL,
    prog_auth_first_name   VARCHAR2(35 CHAR) NOT NULL,
    created_by             VARCHAR2(32 CHAR) NOT NULL,
    created_date           DATE NOT NULL
);

COMMENT ON TABLE progauthority IS
    'Table which houses the name of the authority of the program, the person in charge of the program.';

COMMENT ON COLUMN progauthority.prog_auth_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN progauthority.prog_auth_last_name IS
    'Last name of the program authority.';

COMMENT ON COLUMN progauthority.prog_auth_first_name IS
    'First name of the program authority.';

COMMENT ON COLUMN progauthority.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN progauthority.created_date IS
    'Date that the record was input.';

CREATE INDEX progauthorities__idx ON
    progauthority (
        prog_auth_last_name
    ASC,
        prog_auth_first_name
    ASC );

ALTER TABLE progauthority ADD CONSTRAINT progauthorities_pk PRIMARY KEY ( prog_auth_id );

ALTER TABLE progauthority ADD CONSTRAINT progauthorities__un UNIQUE ( prog_auth_last_name,
                                                                      prog_auth_first_name );

CREATE TABLE program (
    program_id      INTEGER NOT NULL,
    program_name    VARCHAR2(30 CHAR) NOT NULL,
    program_desc    VARCHAR2(4000 CHAR) NOT NULL,
    prog_auth_id    INTEGER NOT NULL,
    org_id          INTEGER NOT NULL,
    program_start   DATE NOT NULL,
    program_end     DATE,
    still_valid     CHAR(1) NOT NULL,
    comments        VARCHAR2(2000 CHAR),
    created_by      VARCHAR2(32 CHAR) NOT NULL,
    created_date    DATE NOT NULL
);

COMMENT ON TABLE program IS
    'Information regarding the program which the event is a part of.';

COMMENT ON COLUMN program.program_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN program.program_name IS
    'Name of the program, must be unique in this table.';

COMMENT ON COLUMN program.program_desc IS
    'Description of the program.';

COMMENT ON COLUMN program.prog_auth_id IS
    'Links to the ProgAuthorities table. The person in charge of the program, the primary investigator.';

COMMENT ON COLUMN program.org_id IS
    'Links to the Organizations table to describe the organization leading the program.';

COMMENT ON COLUMN program.program_start IS
    'Start date of the program, mandatory field.';

COMMENT ON COLUMN program.program_end IS
    'End date of the program.';

COMMENT ON COLUMN program.still_valid IS
    'Boolean, Y or N, that indicates whether this record is still valid,  used to filter in the application and for reporting purposes.'
    ;

COMMENT ON COLUMN program.comments IS
    'Comments regarding the data in this record.';

COMMENT ON COLUMN program.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN program.created_date IS
    'Date that the record was input.';

CREATE INDEX program__idx ON
    program (
        program_name
    ASC,
        org_id
    ASC,
        prog_auth_id
    ASC );

CREATE INDEX program__idxv1 ON
    program (
        still_valid
    ASC );

CREATE INDEX program__idxv2 ON
    program (
        program_name
    ASC );

CREATE INDEX program__idxv3 ON
    program (
        prog_auth_id
    ASC );

CREATE INDEX program__idxv4 ON
    program (
        org_id
    ASC );

ALTER TABLE program ADD CONSTRAINT program_pk PRIMARY KEY ( program_id );

ALTER TABLE program ADD CONSTRAINT program__un UNIQUE ( program_name );

CREATE TABLE protocode (
    proto_id       INTEGER NOT NULL,
    proto_short    VARCHAR2(10 CHAR) NOT NULL,
    proto_desc     VARCHAR2(4000 CHAR) NOT NULL,
    created_by     VARCHAR2(32 CHAR) NOT NULL,
    created_date   DATE NOT NULL
);

COMMENT ON TABLE protocode IS
    'Table for housing the descriptions of the various types of protocols which may be followed during an event. ';

COMMENT ON COLUMN protocode.proto_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN protocode.proto_short IS
    'Unigue, short description.';

COMMENT ON COLUMN protocode.proto_desc IS
    'Long description for the type of protocol.';

COMMENT ON COLUMN protocode.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN protocode.created_date IS
    'Date that the record was input.';

CREATE INDEX protocode__idx ON
    protocode (
        proto_short
    ASC );

ALTER TABLE protocode ADD CONSTRAINT protocode_pk PRIMARY KEY ( proto_id );

ALTER TABLE protocode ADD CONSTRAINT protocode__un UNIQUE ( proto_short );

CREATE TABLE protocol (
    protocol_id      INTEGER NOT NULL,
    program_id       INTEGER NOT NULL,
    proto_id         INTEGER NOT NULL,
    proto_file_id    INTEGER,
    protocol_desc    VARCHAR2(4000 CHAR) NOT NULL,
    protocol_start   DATE NOT NULL,
    protocol_end     DATE,
    still_valid      CHAR(1) NOT NULL,
    comments         VARCHAR2(2000 CHAR),
    created_by       VARCHAR2(32 CHAR) NOT NULL,
    created_date     DATE NOT NULL
);

COMMENT ON TABLE protocol IS
    'Table whichdescribes the protocols. Allows for the tracking of the history of when protocols change.';

COMMENT ON COLUMN protocol.protocol_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN protocol.program_id IS
    'Links to the Programs table to describe the program which the protocol is a part of.';

COMMENT ON COLUMN protocol.proto_id IS
    'Foreign key which links to the ProtoCodes table.';

COMMENT ON COLUMN protocol.proto_file_id IS
    'Links to the ProtoFile table which houses documents to more fully describe the protocol in question, if required..';

COMMENT ON COLUMN protocol.protocol_desc IS
    'Description of the protocol.';

COMMENT ON COLUMN protocol.protocol_start IS
    'Start date for the protocol.';

COMMENT ON COLUMN protocol.protocol_end IS
    'Date that the protocol was deprecated.';

COMMENT ON COLUMN protocol.still_valid IS
    'Boolean, Y or N, that indicates whether this record is still valid,  used to filter in the application and for reporting purposes.'
    ;

COMMENT ON COLUMN protocol.comments IS
    'Comments regarding the data in this record.';

COMMENT ON COLUMN protocol.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN protocol.created_date IS
    'Date that the record was input.';

CREATE INDEX protocol__idx ON
    protocol (
        program_id
    ASC,
        proto_id
    ASC );

CREATE INDEX protocol__idxv1 ON
    protocol (
        still_valid
    ASC );

CREATE INDEX protocol__idxv2 ON
    protocol (
        program_id
    ASC );

CREATE INDEX protocol__idxv3 ON
    protocol (
        proto_id
    ASC );

ALTER TABLE protocol ADD CONSTRAINT protocol_pk PRIMARY KEY ( protocol_id );

ALTER TABLE protocol
    ADD CONSTRAINT protocol__un UNIQUE ( program_id,
                                         proto_id,
                                         protocol_start );

CREATE TABLE protofile (
    proto_file_id   INTEGER NOT NULL,
    protocol_id     INTEGER NOT NULL,
    proto_file      BLOB NOT NULL,
    comments        VARCHAR2(2000 CHAR),
    created_by      VARCHAR2(32 CHAR) NOT NULL,
    created_date    DATE NOT NULL
);

COMMENT ON TABLE protofile IS
    'Table that contains documents which more fully describe the protocols if available.';

COMMENT ON COLUMN protofile.proto_file_id IS
    'System generated unique identifier.';

COMMENT ON COLUMN protofile.protocol_id IS
    'Links to the Protolcs table to identify which protocol the document describes.';

COMMENT ON COLUMN protofile.proto_file IS
    'The file describing the protocol.';

COMMENT ON COLUMN protofile.comments IS
    'Comments regarding the data in this record.';

COMMENT ON COLUMN protofile.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN protofile.created_date IS
    'Date that the record was input.';

ALTER TABLE protofile ADD CONSTRAINT protofile_pk PRIMARY KEY ( proto_file_id );

ALTER TABLE protofile ADD CONSTRAINT protofile__un UNIQUE ( proto_file_id,
                                                            protocol_id );

CREATE TABLE qualcode (
    qual_id        INTEGER NOT NULL,
    qual_short     VARCHAR2(10) NOT NULL,
    qual_desc      VARCHAR2(300) NOT NULL,
    created_by     VARCHAR2(32) NOT NULL,
    created_date   DATE NOT NULL
);

COMMENT ON TABLE qualcode IS
    'Table that houses descriptions for quality codes used to indicate the confidence in a measurement or observation throughout the database.'
    ;

COMMENT ON COLUMN qualcode.qual_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN qualcode.qual_short IS
    'Unigue, short description.';

COMMENT ON COLUMN qualcode.qual_desc IS
    'Long description of the quality of the data value.';

COMMENT ON COLUMN qualcode.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN qualcode.created_date IS
    'Date that the record was input.';

CREATE INDEX qualcode__idx ON
    qualcode (
        qual_short
    ASC );

ALTER TABLE qualcode ADD CONSTRAINT qualcode_pk PRIMARY KEY ( qual_id );

ALTER TABLE qualcode ADD CONSTRAINT qualcode__un UNIQUE ( qual_short );

CREATE TABLE releasesitecode (
    rel_site_id      INTEGER NOT NULL,
    rel_site_short   VARCHAR2(20 CHAR) NOT NULL,
    rel_site_desc    VARCHAR2(450 CHAR) NOT NULL,
    river_id         INTEGER NOT NULL,
    trib_id          INTEGER,
    subriver_id      INTEGER,
    min_latitude     NUMBER(7, 5),
    min_longitude    NUMBER(8, 5),
    max_latitude     NUMBER(7, 5),
    max_longitude    NUMBER(8, 5),
    created_by       VARCHAR2(32 CHAR) NOT NULL,
    created_date     DATE NOT NULL
);

COMMENT ON TABLE releasesitecode IS
    'Table which houses information on the various long term sites used for releases of animals.';

COMMENT ON COLUMN releasesitecode.rel_site_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN releasesitecode.rel_site_short IS
    'Unigue, short description.';

COMMENT ON COLUMN releasesitecode.rel_site_desc IS
    'Long description of the release site.';

COMMENT ON COLUMN releasesitecode.river_id IS
    'Links to the Rivers table for the description of the river system the release site is part of.';

COMMENT ON COLUMN releasesitecode.trib_id IS
    'Links to the Tributaries table for description of the tributary the release site is located on.';

COMMENT ON COLUMN releasesitecode.subriver_id IS
    'Links to the SubRivers table for the description of the subriver the release site is part of.';

COMMENT ON COLUMN releasesitecode.min_latitude IS
    'Minimum latitude of the bounding box which encompasses the release site in decimal degrees.';

COMMENT ON COLUMN releasesitecode.min_longitude IS
    'Minimum longitude of the bounding box which encompasses the release site in decimal degrees.';

COMMENT ON COLUMN releasesitecode.max_latitude IS
    'Maximum latitude of the bounding box which encompasses the release site in decimal degrees.';

COMMENT ON COLUMN releasesitecode.max_longitude IS
    'Maximum longitude of the bounding box which encompasses the release site in decimal degrees.';

COMMENT ON COLUMN releasesitecode.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN releasesitecode.created_date IS
    'Date that the record was input.';

CREATE INDEX releasesitecode__idx ON
    releasesitecode (
        rel_site_short
    ASC );

CREATE INDEX releasesitecode__idxv1 ON
    releasesitecode (
        river_id
    ASC,
        trib_id
    ASC,
        subriver_id
    ASC );

CREATE INDEX releasesitecode__idxv2 ON
    releasesitecode (
        river_id
    ASC );

CREATE INDEX releasesitecode__idxv3 ON
    releasesitecode (
        trib_id
    ASC );

CREATE INDEX releasesitecode__idxv4 ON
    releasesitecode (
        subriver_id
    ASC );

ALTER TABLE releasesitecode ADD CONSTRAINT releasesitecode_pk PRIMARY KEY ( rel_site_id );

ALTER TABLE releasesitecode ADD CONSTRAINT releasesitecode__un UNIQUE ( rel_site_short );

CREATE TABLE rivercode (
    river_id       INTEGER NOT NULL,
    river_short    VARCHAR2(10 CHAR) NOT NULL,
    river_desc     VARCHAR2(200 CHAR) NOT NULL,
    created_by     VARCHAR2(32 CHAR) NOT NULL,
    created_date   DATE NOT NULL
);

COMMENT ON TABLE rivercode IS
    'Table which houses the description of the river system.';

COMMENT ON COLUMN rivercode.river_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN rivercode.river_short IS
    'Unigue, short description.';

COMMENT ON COLUMN rivercode.river_desc IS
    'Long description of the river.';

COMMENT ON COLUMN rivercode.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN rivercode.created_date IS
    'Date that the record was input.';

CREATE INDEX rivercode__idx ON
    rivercode (
        river_short
    ASC );

ALTER TABLE rivercode ADD CONSTRAINT rivercode_pk PRIMARY KEY ( river_id );

ALTER TABLE rivercode ADD CONSTRAINT rivercode__un UNIQUE ( river_short );

CREATE TABLE rolecode (
    role_id        INTEGER NOT NULL,
    role_short     VARCHAR2(10 CHAR) NOT NULL,
    role_desc      VARCHAR2(60 CHAR) NOT NULL,
    created_by     VARCHAR2(32 CHAR) NOT NULL,
    created_date   DATE NOT NULL
);

COMMENT ON TABLE rolecode IS
    'Table that contains the descriptions of the various possible roles or tasks which a team member has.';

COMMENT ON COLUMN rolecode.role_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN rolecode.role_short IS
    'Unigue, short description.';

COMMENT ON COLUMN rolecode.role_desc IS
    'Long description of the role.';

COMMENT ON COLUMN rolecode.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN rolecode.created_date IS
    'Date that the record was input.';

CREATE INDEX rolecode__idx ON
    rolecode (
        role_short
    ASC );

ALTER TABLE rolecode ADD CONSTRAINT rolecode_pk PRIMARY KEY ( role_id );

ALTER TABLE rolecode ADD CONSTRAINT rolecode__un UNIQUE ( role_short );

CREATE TABLE sample (
    sample_id       INTEGER NOT NULL,
    location_id     INTEGER NOT NULL,
    sample_fishno   NUMBER(4) NOT NULL,
    spec_id         INTEGER NOT NULL,
    samp_id         INTEGER NOT NULL,
    comments        VARCHAR2(2000 CHAR),
    created_by      VARCHAR2(32 CHAR) NOT NULL,
    created_date    DATE NOT NULL
);

COMMENT ON TABLE sample IS
    'Table that houses information on sampling performed at a location during an event.';

COMMENT ON COLUMN sample.sample_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN sample.location_id IS
    'Links to the Locations table to describe where the sampling was performed.';

COMMENT ON COLUMN sample.sample_fishno IS
    'The fish number assigned to the animal for sampling purposes.';

COMMENT ON COLUMN sample.spec_id IS
    'Links to the SpeciesCodes table to describe the species sampled.';

COMMENT ON COLUMN sample.samp_id IS
    'Links to the SampleCodes table to describe the type of sample performed.';

COMMENT ON COLUMN sample.comments IS
    'Comments regarding the data in this record.';

COMMENT ON COLUMN sample.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN sample.created_date IS
    'Date that the record was input.';

CREATE INDEX sample__idx ON
    sample (
        location_id
    ASC );

CREATE INDEX sample__idxv1 ON
    sample (
        spec_id
    ASC );

CREATE INDEX sample__idxv2 ON
    sample (
        samp_id
    ASC );

ALTER TABLE sample ADD CONSTRAINT sample_pk PRIMARY KEY ( sample_id );

ALTER TABLE sample
    ADD CONSTRAINT sample__un UNIQUE ( location_id,
                                       samp_id,
                                       spec_id,
                                       sample_fishno );

CREATE TABLE samplecode (
    samp_id        INTEGER NOT NULL,
    samp_short     VARCHAR2(10 CHAR) NOT NULL,
    samp_desc      VARCHAR2(35 CHAR) NOT NULL,
    created_by     VARCHAR2(32 CHAR) NOT NULL,
    created_date   DATE NOT NULL
);

COMMENT ON TABLE samplecode IS
    'Table that describes the type of sampling performed.';

COMMENT ON COLUMN samplecode.samp_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN samplecode.samp_short IS
    'Unigue, short description.';

COMMENT ON COLUMN samplecode.samp_desc IS
    'Long description of the type of sample.';

COMMENT ON COLUMN samplecode.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN samplecode.created_date IS
    'Date that the record was input.';

CREATE INDEX samplecode__idx ON
    samplecode (
        samp_short
    ASC );

ALTER TABLE samplecode ADD CONSTRAINT samplecode_pk PRIMARY KEY ( samp_id );

ALTER TABLE samplecode ADD CONSTRAINT samplecode__un UNIQUE ( samp_short );

CREATE TABLE sampledet (
    samp_det_id       INTEGER NOT NULL,
    sample_id         INTEGER NOT NULL,
    ani_det_id        INTEGER NOT NULL,
    val               NUMBER(11, 5),
    ani_det_subj_id   INTEGER,
    qual_id           INTEGER NOT NULL,
    comments          VARCHAR2(2000 CHAR),
    created_by        VARCHAR2(32 CHAR) NOT NULL,
    created_date      DATE NOT NULL
);

COMMENT ON TABLE sampledet IS
    'Table that houses the detailed information for a sampling event at a location. For example fish length for an animal sampled in the wild.'
    ;

COMMENT ON COLUMN sampledet.samp_det_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN sampledet.sample_id IS
    'Links to the Samples table to identify the individual fish that the sample details relate to.';

COMMENT ON COLUMN sampledet.ani_det_id IS
    'Links to the AniDetCodes table to describe the type of measurement.';

COMMENT ON COLUMN sampledet.val IS
    'The value of the measurement if not a subjective observation.';

COMMENT ON COLUMN sampledet.ani_det_subj_id IS
    'Links to the AniDetSubjCodes table to describe the subjective observation.';

COMMENT ON COLUMN sampledet.qual_id IS
    'Links to the QualCodes table to decsribe the quality of the measurement or observation.';

COMMENT ON COLUMN sampledet.comments IS
    'Comments regarding the data in this record.';

COMMENT ON COLUMN sampledet.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN sampledet.created_date IS
    'Date that the record was input.';

CREATE INDEX sampledet__idx ON
    sampledet (
        sample_id
    ASC,
        ani_det_id
    ASC,
        ani_det_subj_id
    ASC );

CREATE INDEX sampledet__idxv1 ON
    sampledet (
        qual_id
    ASC );

CREATE INDEX sampledet__idxv2 ON
    sampledet (
        sample_id
    ASC );

CREATE INDEX sampledet__idxv3 ON
    sampledet (
        ani_det_id
    ASC );

CREATE INDEX sampledet__idxv4 ON
    sampledet (
        ani_det_subj_id
    ASC );

ALTER TABLE sampledet
    ADD CONSTRAINT sampledet_ck_1 CHECK ( val IS NOT NULL
                                          OR ani_det_subj_id IS NOT NULL );

ALTER TABLE sampledet ADD CONSTRAINT sampledet_pk PRIMARY KEY ( samp_det_id );

ALTER TABLE sampledet ADD CONSTRAINT sampledet__un UNIQUE ( sample_id,
                                                            ani_det_id );

CREATE TABLE sire (
    sire_id        INTEGER NOT NULL,
    priority_id    INTEGER NOT NULL,
    pair_id        INTEGER NOT NULL,
    ufid           VARCHAR2(50 CHAR) NOT NULL,
    choice         NUMBER(1) NOT NULL,
    comments       VARCHAR2(2000 CHAR),
    created_by     VARCHAR2(32 CHAR) NOT NULL,
    created_date   DATE NOT NULL
);

COMMENT ON TABLE sire IS
    'Table used to track possible mutiple sires involved in the pairing.';

COMMENT ON COLUMN sire.sire_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN sire.priority_id IS
    'Links to the PriorityCode table.';

COMMENT ON COLUMN sire.pair_id IS
    'Links to the Pair table.';

COMMENT ON COLUMN sire.ufid IS
    'The unique fish ID of the sire, links to the Individual table.';

COMMENT ON COLUMN sire.choice IS
    'Number indicating whether the sire recorded is first, second, third, etc. choice for the spawning.';

COMMENT ON COLUMN sire.comments IS
    'Comments regarding the data in this record.';

COMMENT ON COLUMN sire.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN sire.created_date IS
    'Date that the record was input.';

CREATE INDEX sire__idx ON
    sire (
        priority_id
    ASC );

CREATE INDEX sire__idxv1 ON
    sire (
        pair_id
    ASC );

CREATE INDEX sire__idxv3 ON
    sire (
        ufid
    ASC );

CREATE INDEX sire__idxv4 ON
    sire (
        choice
    ASC );

ALTER TABLE sire ADD CONSTRAINT sire_pk PRIMARY KEY ( sire_id );

CREATE TABLE spawndet (
    spawn_detail_id     INTEGER NOT NULL,
    spawn_id            INTEGER NOT NULL,
    spawn_det_id        INTEGER NOT NULL,
    val                 NUMBER(11, 5),
    spawn_det_subj_id   INTEGER,
    qual_id             INTEGER NOT NULL,
    comments            VARCHAR2(2000 CHAR),
    created_by          VARCHAR2(32 CHAR) NOT NULL,
    created_date        DATE NOT NULL
);

COMMENT ON TABLE spawndet IS
    'Table which houses details on the spawning of a pair. The information collected may either be subjective or a measurement. For example milt quality would be observational, or subjective while milt volume would be a measurement in the Val column.'
    ;

COMMENT ON COLUMN spawndet.spawn_detail_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN spawndet.spawn_id IS
    'Links to the Spawnings table.';

COMMENT ON COLUMN spawndet.spawn_det_id IS
    'Links to the SapwnDetCodes table to indicate what detail the value of the subjective code is for.';

COMMENT ON COLUMN spawndet.val IS
    'The value of the measurement if not a subjective observation.';

COMMENT ON COLUMN spawndet.spawn_det_subj_id IS
    'Links to the SpawnDetSubjCodes table, identifies the subjective observation.';

COMMENT ON COLUMN spawndet.qual_id IS
    'Links to the QualCodes table to indicate the quality for the measurement or observation.';

COMMENT ON COLUMN spawndet.comments IS
    'Comments regarding the data in this record.';

COMMENT ON COLUMN spawndet.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN spawndet.created_date IS
    'Date that the record was input.';

CREATE INDEX spawndet__idx ON
    spawndet (
        spawn_id
    ASC,
        spawn_det_id
    ASC,
        spawn_det_subj_id
    ASC );

CREATE INDEX spawndet__idxv1 ON
    spawndet (
        qual_id
    ASC );

CREATE INDEX spawndet__idxv2 ON
    spawndet (
        spawn_id
    ASC );

CREATE INDEX spawndet__idxv3 ON
    spawndet (
        spawn_det_id
    ASC );

CREATE INDEX spawndet__idxv4 ON
    spawndet (
        spawn_det_subj_id
    ASC );

ALTER TABLE spawndet
    ADD CONSTRAINT spawndet_ck_1 CHECK ( val IS NOT NULL
                                         OR spawn_det_subj_id IS NOT NULL );

ALTER TABLE spawndet ADD CONSTRAINT spawndet_pk PRIMARY KEY ( spawn_detail_id );

ALTER TABLE spawndet ADD CONSTRAINT spawndet__un UNIQUE ( spawn_id,
                                                          spawn_det_id );

CREATE TABLE spawndetcode (
    spawn_det_id      INTEGER NOT NULL,
    spawn_det_short   VARCHAR2(10 CHAR) NOT NULL,
    spawn_det_desc    VARCHAR2(200 CHAR) NOT NULL,
    min_val           NUMBER(11, 5) NOT NULL,
    max_val           NUMBER(11, 5) NOT NULL,
    unit_id           INTEGER,
    spawn_subj_flag   CHAR(1) NOT NULL,
    created_by        VARCHAR2(32 CHAR) NOT NULL,
    created_date      DATE NOT NULL
);

COMMENT ON TABLE spawndetcode IS
    'Table that houses the various possible measurements or subjective types of observations which may be recorded during a spawning.'
    ;

COMMENT ON COLUMN spawndetcode.spawn_det_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN spawndetcode.spawn_det_short IS
    'Unigue, short description.';

COMMENT ON COLUMN spawndetcode.spawn_det_desc IS
    'Long description of the detail.';

COMMENT ON COLUMN spawndetcode.min_val IS
    'Minimum value permitted for the detail, used in quality assurance.';

COMMENT ON COLUMN spawndetcode.max_val IS
    'Maximum value for the detail recorded, used for quality assurance.';

COMMENT ON COLUMN spawndetcode.unit_id IS
    'The unit of measure, if not an observation.';

COMMENT ON COLUMN spawndetcode.spawn_subj_flag IS
    'Boolean field, Y or N, indicating if the detail is subjective of not.';

COMMENT ON COLUMN spawndetcode.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN spawndetcode.created_date IS
    'Date that the record was input.';

CREATE INDEX spawndetcode__idx ON
    spawndetcode (
        spawn_det_short
    ASC );

CREATE INDEX spawndetcode__idxv1 ON
    spawndetcode (
        unit_id
    ASC );

CREATE INDEX spawndetcode__idxv2 ON
    spawndetcode (
        spawn_det_short
    ASC,
        spawn_subj_flag
    ASC );

CREATE INDEX spawndetcode__idxv4 ON
    spawndetcode (
        spawn_subj_flag
    ASC );

ALTER TABLE spawndetcode
    ADD CONSTRAINT spawndetcode_ck_1 CHECK ( NOT ( spawn_subj_flag = 'Y'
                                                   AND unit_id IS NOT NULL ) );

ALTER TABLE spawndetcode ADD CONSTRAINT spawndetcode_pk PRIMARY KEY ( spawn_det_id );

ALTER TABLE spawndetcode ADD CONSTRAINT spawndetcode__un UNIQUE ( spawn_det_short );

CREATE TABLE spawndetsubjcode (
    spawn_det_subj_id   INTEGER NOT NULL,
    spawn_det_id        INTEGER NOT NULL,
    spawn_subj_short    VARCHAR2(10 CHAR) NOT NULL,
    spawn_subj_desc     VARCHAR2(200 CHAR) NOT NULL,
    created_by          VARCHAR2(32 CHAR) NOT NULL,
    created_date        DATE NOT NULL
);

COMMENT ON TABLE spawndetsubjcode IS
    'Table that houses the information describing the subjective, or observational, information collected during a spawning.';

COMMENT ON COLUMN spawndetsubjcode.spawn_det_subj_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN spawndetsubjcode.spawn_det_id IS
    'Links to the SpawnDetCodes table to describe the type of observation being recorded.';

COMMENT ON COLUMN spawndetsubjcode.spawn_subj_short IS
    'Unigue, short description.';

COMMENT ON COLUMN spawndetsubjcode.spawn_subj_desc IS
    'Long description of the observation made.';

COMMENT ON COLUMN spawndetsubjcode.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN spawndetsubjcode.created_date IS
    'Date that the record was input.';

CREATE INDEX spawndetsubjcode__idx ON
    spawndetsubjcode (
        spawn_det_id
    ASC,
        spawn_subj_short
    ASC );

CREATE INDEX spawndetsubjcode__idxv1 ON
    spawndetsubjcode (
        spawn_det_id
    ASC );

CREATE INDEX spawndetsubjcode__idxv2 ON
    spawndetsubjcode (
        spawn_subj_short
    ASC );

ALTER TABLE spawndetsubjcode ADD CONSTRAINT spawndetsubjcode_pk PRIMARY KEY ( spawn_det_subj_id );

ALTER TABLE spawndetsubjcode ADD CONSTRAINT spawndetsubjcode__un UNIQUE ( spawn_subj_short );

--  A sapwning can only happen at one point in time, so the detail information
--  is related to that spawning only, unlike other details on an animal, for
--  example the fish length might be measured many times and change through the
--  life of the animal. So the detail of an animal must relate back to the XREF
--  table, but each spawning is a thing unto itself.
CREATE TABLE spawning (
    spawn_id        INTEGER NOT NULL,
    pair_id         INTEGER NOT NULL,
    spawn_date      DATE NOT NULL,
    est_fecundity   NUMBER(10, 2) NOT NULL,
    comments        VARCHAR2(2000 CHAR),
    created_by      VARCHAR2(32 CHAR) NOT NULL,
    created_date    DATE NOT NULL
);

COMMENT ON TABLE spawning IS
    'Table that houses information on specific spawnings. One spawning event may last many days, and may have many pairs spawned during the event.'
    ;

COMMENT ON COLUMN spawning.spawn_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN spawning.pair_id IS
    'Links to the Pairings table to identify which pair has been spawned.';

COMMENT ON COLUMN spawning.spawn_date IS
    'The date the spawning took place.';

COMMENT ON COLUMN spawning.est_fecundity IS
    'Estimated fecunidty based on the dam''s stock, collection, and length at time of spawning. Information in the Fecunitites table is used to arrive at the esitimate.'
    ;

COMMENT ON COLUMN spawning.comments IS
    'Comments regarding the data in this record.';

COMMENT ON COLUMN spawning.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN spawning.created_date IS
    'Date that the record was input.';

CREATE INDEX spawning__idx ON
    spawning (
        pair_id
    ASC,
        spawn_date
    ASC );

CREATE INDEX spawning__idxv1 ON
    spawning (
        pair_id
    ASC );

ALTER TABLE spawning ADD CONSTRAINT spawning_pk PRIMARY KEY ( spawn_id );

ALTER TABLE spawning ADD CONSTRAINT spawning__un UNIQUE ( pair_id,
                                                          spawn_date );

CREATE TABLE speciescode (
    spec_id        INTEGER NOT NULL,
    spec_short     VARCHAR2(10 CHAR) NOT NULL,
    species        VARCHAR2(100 CHAR) NOT NULL,
    common_name    VARCHAR2(35 CHAR),
    created_by     VARCHAR2(32 CHAR) NOT NULL,
    created_date   DATE NOT NULL
);

COMMENT ON TABLE speciescode IS
    'Table which describes the species associated with the data in the database, default is currently Atlantic Salmon for all tables other than sampling.'
    ;

COMMENT ON COLUMN speciescode.spec_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN speciescode.spec_short IS
    'Unigue, short description.';

COMMENT ON COLUMN speciescode.species IS
    'The taxonomic name for the species.';

COMMENT ON COLUMN speciescode.common_name IS
    'The common name of the species.';

COMMENT ON COLUMN speciescode.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN speciescode.created_date IS
    'Date that the record was input.';

CREATE INDEX speciescode__idx ON
    speciescode (
        spec_short
    ASC,
        species
    ASC,
        common_name
    ASC );

CREATE INDEX speciescode__idxv1 ON
    speciescode (
        spec_short
    ASC );

CREATE INDEX speciescode__idxv2 ON
    speciescode (
        common_name
    ASC );

CREATE INDEX speciescode__idxv3 ON
    speciescode (
        species
    ASC );

ALTER TABLE speciescode ADD CONSTRAINT speciescode_pk PRIMARY KEY ( spec_id );

ALTER TABLE speciescode ADD CONSTRAINT speciescode__un UNIQUE ( spec_short );

CREATE TABLE stockcode (
    stock_id       INTEGER NOT NULL,
    stock_short    VARCHAR2(15 CHAR) NOT NULL,
    stock_desc     VARCHAR2(100 CHAR) NOT NULL,
    created_by     VARCHAR2(32 CHAR) NOT NULL,
    created_date   DATE NOT NULL
);

COMMENT ON TABLE stockcode IS
    'Table that houses the descriptions of the various stocks of the animals.';

COMMENT ON COLUMN stockcode.stock_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN stockcode.stock_short IS
    'Unigue, short description.';

COMMENT ON COLUMN stockcode.stock_desc IS
    'Long description of the stock.';

COMMENT ON COLUMN stockcode.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN stockcode.created_date IS
    'Date that the record was input.';

CREATE INDEX stockcode__idx ON
    stockcode (
        stock_short
    ASC );

ALTER TABLE stockcode ADD CONSTRAINT stockcode_pk PRIMARY KEY ( stock_id );

ALTER TABLE stockcode ADD CONSTRAINT stockcode__un UNIQUE ( stock_short );

CREATE TABLE subrivercode ( 
--  Use to house various subares on a river way which are frequented for the
--  work. Include simply bounding box coords, plus name, plus description
    subriver_id      INTEGER NOT NULL,
    river_id         INTEGER NOT NULL,
    trib_id          INTEGER,
    subriver_short   VARCHAR2(10 CHAR) NOT NULL,
    subriver_desc    VARCHAR2(1000 CHAR) NOT NULL,
    created_by       VARCHAR2(32 CHAR) NOT NULL,
    created_date     DATE NOT NULL
);

COMMENT ON TABLE subrivercode IS
    'The table which describes the subriver of the event location. This table allows for reporting on specific parts of a river system.'
    ;

COMMENT ON COLUMN subrivercode.subriver_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN subrivercode.river_id IS
    'Links to the RiverCodes table for the description of the river system the subriver area is part of.';

COMMENT ON COLUMN subrivercode.trib_id IS
    'Links to the Tributaries table if the subriver is part of a tributary. Optional.';

COMMENT ON COLUMN subrivercode.subriver_short IS
    'Unigue, short description.';

COMMENT ON COLUMN subrivercode.subriver_desc IS
    'Long description of the river area.';

COMMENT ON COLUMN subrivercode.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN subrivercode.created_date IS
    'Date that the record was input.';

CREATE INDEX subrivercode__idx ON
    subrivercode (
        subriver_short
    ASC );

CREATE INDEX subrivercode__idxv1 ON
    subrivercode (
        river_id
    ASC,
        trib_id
    ASC );

CREATE INDEX subrivercode__idxv2 ON
    subrivercode (
        river_id
    ASC );

CREATE INDEX subrivercode__idxv3 ON
    subrivercode (
        trib_id
    ASC );

ALTER TABLE subrivercode ADD CONSTRAINT subrivercode_pk PRIMARY KEY ( subriver_id );

ALTER TABLE subrivercode ADD CONSTRAINT subrivercode__un UNIQUE ( subriver_short );

CREATE TABLE tank (
    tank_id        INTEGER NOT NULL,
    tank_short     VARCHAR2(15 CHAR) NOT NULL,
    tank_desc      VARCHAR2(35 CHAR) NOT NULL,
    created_by     VARCHAR2(32 CHAR) NOT NULL,
    created_date   DATE NOT NULL
);

COMMENT ON TABLE tank IS
    'Table that uniquely identifies the tanks in use in the facilities.';

COMMENT ON COLUMN tank.tank_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN tank.tank_short IS
    'Unigue, short description.';

COMMENT ON COLUMN tank.tank_desc IS
    'Longer description of the container.';

COMMENT ON COLUMN tank.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN tank.created_date IS
    'Date that the record was input.';

CREATE INDEX tank__idx ON
    tank (
        tank_short
    ASC );

ALTER TABLE tank ADD CONSTRAINT tank_pk PRIMARY KEY ( tank_id );

ALTER TABLE tank ADD CONSTRAINT tank__un UNIQUE ( tank_short );

CREATE TABLE tankdet (
    tank_det_id        INTEGER NOT NULL,
    tank_id            INTEGER NOT NULL,
    cont_det_id        INTEGER NOT NULL,
    val                NUMBER(11, 5),
    cont_det_subj_id   INTEGER,
    tank_det_start     DATE NOT NULL,
    tank_det_end       DATE,
    still_valid        CHAR(1) NOT NULL,
    comments           VARCHAR2(2000 CHAR),
    created_by         VARCHAR2(32 CHAR) NOT NULL,
    created_date       DATE NOT NULL
);

COMMENT ON TABLE tankdet IS
    'Table that houses the various details for a tank.';

COMMENT ON COLUMN tankdet.tank_det_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN tankdet.tank_id IS
    'Links to the Tanks table.';

COMMENT ON COLUMN tankdet.cont_det_id IS
    'Links to the ContainerDetCodes table to describe the type of detail recorded.';

COMMENT ON COLUMN tankdet.val IS
    'The value of the measurement if not a subjective observation.';

COMMENT ON COLUMN tankdet.cont_det_subj_id IS
    'Links to the ContDetSubjCodes table to describe the observation.';

COMMENT ON COLUMN tankdet.tank_det_start IS
    'The date that the detail was recorded, mandatory.';

COMMENT ON COLUMN tankdet.tank_det_end IS
    'The last date which the detail is still valid.';

COMMENT ON COLUMN tankdet.still_valid IS
    'Boolean, Y or N, that indicates whether this record is still valid,  used to filter in the application and for reporting purposes.'
    ;

COMMENT ON COLUMN tankdet.comments IS
    'Comments regarding the data in this record.';

COMMENT ON COLUMN tankdet.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN tankdet.created_date IS
    'Date that the record was input.';

CREATE INDEX tankdet__idx ON
    tankdet (
        tank_id
    ASC,
        cont_det_id
    ASC,
        cont_det_subj_id
    ASC );

CREATE INDEX tankdet__idxv1 ON
    tankdet (
        still_valid
    ASC );

CREATE INDEX tankdet__idxv2 ON
    tankdet (
        tank_id
    ASC );

CREATE INDEX tankdet__idxv3 ON
    tankdet (
        cont_det_id
    ASC );

CREATE INDEX tankdet__idxv4 ON
    tankdet (
        cont_det_subj_id
    ASC );

ALTER TABLE tankdet
    ADD CONSTRAINT tankdet_ck_1 CHECK ( val IS NOT NULL
                                        OR cont_det_subj_id IS NOT NULL );

ALTER TABLE tankdet ADD CONSTRAINT tankdet_pk PRIMARY KEY ( tank_det_id );

ALTER TABLE tankdet
    ADD CONSTRAINT tankdet__un UNIQUE ( tank_id,
                                        cont_det_id,
                                        cont_det_subj_id,
                                        tank_det_start );

CREATE TABLE team (
    team_id        INTEGER NOT NULL,
    per_id         INTEGER NOT NULL,
    role_id        INTEGER NOT NULL,
    created_by     VARCHAR2(32 CHAR) NOT NULL,
    created_date   DATE NOT NULL
);

COMMENT ON TABLE team IS
    'Table that houses the make up of a team performing the work associated with an event, the people and their roles on the team.'
    ;

COMMENT ON COLUMN team.team_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN team.per_id IS
    'Foreign key that links to the PersonnelCodes table.';

COMMENT ON COLUMN team.role_id IS
    'Foreign key that links to the RoleCodes table.';

COMMENT ON COLUMN team.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN team.created_date IS
    'Date that the record was input.';

CREATE INDEX team__idx ON
    team (
        per_id
    ASC );

CREATE INDEX team__idxv1 ON
    team (
        role_id
    ASC );

ALTER TABLE team ADD CONSTRAINT team_pk PRIMARY KEY ( team_id );

ALTER TABLE team ADD CONSTRAINT team__un UNIQUE ( per_id,
                                                  role_id );

CREATE TABLE tray (
    tray_id        INTEGER NOT NULL,
    tray_short     VARCHAR2(10 CHAR) NOT NULL,
    tray_desc      VARCHAR2(35 CHAR) NOT NULL,
    created_by     VARCHAR2(32 CHAR) NOT NULL,
    created_date   DATE NOT NULL
);

COMMENT ON TABLE tray IS
    'Table that uniquely identifies the trays in use in the facilities.';

COMMENT ON COLUMN tray.tray_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN tray.tray_short IS
    'Unigue, short description.';

COMMENT ON COLUMN tray.tray_desc IS
    'Longer description of the container.';

COMMENT ON COLUMN tray.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN tray.created_date IS
    'Date that the record was input.';

CREATE INDEX tray__idx ON
    tray (
        tray_short
    ASC );

ALTER TABLE tray ADD CONSTRAINT tray_pk PRIMARY KEY ( tray_id );

ALTER TABLE tray ADD CONSTRAINT tray__un UNIQUE ( tray_short );

CREATE TABLE traydet (
    tray_det_id        INTEGER NOT NULL,
    tray_id            INTEGER NOT NULL,
    cont_det_id        INTEGER NOT NULL,
    val                NUMBER(11, 5),
    cont_det_subj_id   INTEGER,
    tray_det_start     DATE NOT NULL,
    tray_det_end       DATE,
    still_valid        CHAR(1) NOT NULL,
    comments           VARCHAR2(2000 CHAR),
    created_by         VARCHAR2(32 CHAR) NOT NULL,
    created_date       DATE NOT NULL
);

COMMENT ON TABLE traydet IS
    'Table that houses the various details for a tray.';

COMMENT ON COLUMN traydet.tray_det_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN traydet.cont_det_id IS
    'Links to the ContainerDetCodes table to describe the type of detail recorded.';

COMMENT ON COLUMN traydet.val IS
    'The value of the measurement if not a subjective observation.';

COMMENT ON COLUMN traydet.cont_det_subj_id IS
    'Links to the ContDetSubjCodes table to describe the observation.';

COMMENT ON COLUMN traydet.tray_det_start IS
    'The date that the detail was recorded, mandatory.';

COMMENT ON COLUMN traydet.tray_det_end IS
    'The last date which the detail is still valid.';

COMMENT ON COLUMN traydet.still_valid IS
    'Boolean, Y or N, that indicates whether this record is still valid,  used to filter in the application and for reporting purposes.'
    ;

COMMENT ON COLUMN traydet.comments IS
    'Comments regarding the data in this record.';

COMMENT ON COLUMN traydet.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN traydet.created_date IS
    'Date that the record was input.';

CREATE INDEX traydet__idx ON
    traydet (
        tray_id
    ASC,
        cont_det_id
    ASC,
        cont_det_subj_id
    ASC );

CREATE INDEX traydet__idxv1 ON
    traydet (
        still_valid
    ASC );

CREATE INDEX traydet__idxv2 ON
    traydet (
        tray_id
    ASC );

CREATE INDEX traydet__idxv3 ON
    traydet (
        cont_det_id
    ASC );

CREATE INDEX traydet__idxv4 ON
    traydet (
        cont_det_subj_id
    ASC );

ALTER TABLE traydet
    ADD CONSTRAINT traydet_ck_1 CHECK ( val IS NOT NULL
                                        OR cont_det_subj_id IS NOT NULL );

ALTER TABLE traydet ADD CONSTRAINT traydet_pk PRIMARY KEY ( tray_det_id );

ALTER TABLE traydet
    ADD CONSTRAINT traydet__un UNIQUE ( tray_id,
                                        cont_det_id,
                                        cont_det_subj_id,
                                        tray_det_start );

CREATE TABLE tributary (
    trib_id        INTEGER NOT NULL,
    river_id       INTEGER NOT NULL,
    trib_short     VARCHAR2(15 CHAR) NOT NULL,
    trib_desc      VARCHAR2(400 CHAR) NOT NULL,
    created_by     VARCHAR2(32 CHAR) NOT NULL,
    created_date   DATE NOT NULL
);

COMMENT ON TABLE tributary IS
    'Table which houses the information on a tributary.';

COMMENT ON COLUMN tributary.trib_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN tributary.river_id IS
    'Links to the description of the river system.';

COMMENT ON COLUMN tributary.trib_short IS
    'Unigue, short description.';

COMMENT ON COLUMN tributary.trib_desc IS
    'Long description of the tributary.';

COMMENT ON COLUMN tributary.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN tributary.created_date IS
    'Date that the record was input.';

CREATE INDEX tributary__idx ON
    tributary (
        trib_short
    ASC );

CREATE INDEX tributary__idxv1 ON
    tributary (
        river_id
    ASC );

ALTER TABLE tributary ADD CONSTRAINT tributary_pk PRIMARY KEY ( trib_id );

ALTER TABLE tributary ADD CONSTRAINT tributary__un UNIQUE ( trib_short );

CREATE TABLE trough (
    trough_id      INTEGER NOT NULL,
    trough_short   VARCHAR2(10 CHAR) NOT NULL,
    trough_desc    VARCHAR2(250 CHAR) NOT NULL,
    created_by     VARCHAR2(32 CHAR) NOT NULL,
    created_date   DATE NOT NULL
);

COMMENT ON TABLE trough IS
    'Table that uniquely identifies the troughs in use in the facilities.';

COMMENT ON COLUMN trough.trough_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN trough.trough_short IS
    'Unigue, short description.';

COMMENT ON COLUMN trough.trough_desc IS
    'Longer description of the container.';

COMMENT ON COLUMN trough.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN trough.created_date IS
    'Date that the record was input.';

CREATE INDEX trough__idx ON
    trough (
        trough_short
    ASC );

ALTER TABLE trough ADD CONSTRAINT trough_pk PRIMARY KEY ( trough_id );

ALTER TABLE trough ADD CONSTRAINT trough__un UNIQUE ( trough_short );

CREATE TABLE troughdet (
    trough_det_id      INTEGER NOT NULL,
    trough_id          INTEGER NOT NULL,
    cont_det_id        INTEGER NOT NULL,
    val                NUMBER(11, 5),
    cont_det_subj_id   INTEGER,
    trough_det_start   DATE NOT NULL,
    trough_det_end     DATE,
    still_valid        CHAR(1) NOT NULL,
    comments           VARCHAR2(2000 CHAR),
    created_by         VARCHAR2(32 CHAR) NOT NULL,
    created_date       DATE NOT NULL
);

COMMENT ON TABLE troughdet IS
    'Table that houses the various details for a trough.';

COMMENT ON COLUMN troughdet.trough_det_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN troughdet.trough_id IS
    'Links to the Troughs table.';

COMMENT ON COLUMN troughdet.cont_det_id IS
    'Links to the ContainerDetCodes table to describe the type of detail recorded.';

COMMENT ON COLUMN troughdet.val IS
    'The value of the measurement if not a subjective observation.';

COMMENT ON COLUMN troughdet.cont_det_subj_id IS
    'Links to the ContDetSubjCodes table to describe the observation.';

COMMENT ON COLUMN troughdet.trough_det_start IS
    'The date that the detail was recorded, mandatory.';

COMMENT ON COLUMN troughdet.trough_det_end IS
    'The last date which the detail is still valid.';

COMMENT ON COLUMN troughdet.still_valid IS
    'Boolean, Y or N, that indicates whether this record is still valid,  used to filter in the application and for reporting purposes.'
    ;

COMMENT ON COLUMN troughdet.comments IS
    'Comments regarding the data in this record.';

COMMENT ON COLUMN troughdet.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN troughdet.created_date IS
    'Date that the record was input.';

CREATE INDEX troughdet__idx ON
    troughdet (
        trough_id
    ASC,
        cont_det_id
    ASC,
        cont_det_subj_id
    ASC );

CREATE INDEX troughdet__idxv1 ON
    troughdet (
        still_valid
    ASC );

CREATE INDEX troughdet__idxv2 ON
    troughdet (
        trough_id
    ASC );

CREATE INDEX troughdet__idxv3 ON
    troughdet (
        cont_det_id
    ASC );

CREATE INDEX troughdet__idxv4 ON
    troughdet (
        cont_det_subj_id
    ASC );

ALTER TABLE troughdet
    ADD CONSTRAINT troughdet_ck_1 CHECK ( val IS NOT NULL
                                          OR cont_det_subj_id IS NOT NULL );

ALTER TABLE troughdet ADD CONSTRAINT troughdet_pk PRIMARY KEY ( trough_det_id );

ALTER TABLE troughdet
    ADD CONSTRAINT troughdet__un UNIQUE ( trough_id,
                                          cont_det_id,
                                          cont_det_subj_id,
                                          trough_det_start );

CREATE TABLE unitcode (
    unit_id        INTEGER NOT NULL,
    unit_short     VARCHAR2(10 CHAR) NOT NULL,
    unit_desc      VARCHAR2(30 CHAR) NOT NULL,
    created_by     VARCHAR2(32 CHAR) NOT NULL,
    created_date   DATE NOT NULL
);

COMMENT ON TABLE unitcode IS
    'Table that houses the descriptions of units of measure used throughout the database.';

COMMENT ON COLUMN unitcode.unit_id IS
    'System generated primary key for the table.';

COMMENT ON COLUMN unitcode.unit_short IS
    'Unigue, short description.';

COMMENT ON COLUMN unitcode.unit_desc IS
    'Long description of the unit of measure.';

COMMENT ON COLUMN unitcode.created_by IS
    'The user name of the account which created the record.';

COMMENT ON COLUMN unitcode.created_date IS
    'Date that the record was input.';

CREATE INDEX unitcode__idx ON
    unitcode (
        unit_short
    ASC );

ALTER TABLE unitcode ADD CONSTRAINT unitcode_pk PRIMARY KEY ( unit_id );

ALTER TABLE unitcode ADD CONSTRAINT unitcode__un UNIQUE ( unit_short );

ALTER TABLE anidetailxref
    ADD CONSTRAINT anidetailxref_contxref_fk FOREIGN KEY ( container_xref_id )
        REFERENCES containerxref ( container_xref_id );

ALTER TABLE anidetailxref
    ADD CONSTRAINT anidetailxref_event_fk FOREIGN KEY ( event_id )
        REFERENCES event ( event_id );

ALTER TABLE anidetailxref
    ADD CONSTRAINT anidetailxref_group_fk FOREIGN KEY ( group_id )
        REFERENCES "GROUP" ( group_id );

ALTER TABLE anidetailxref
    ADD CONSTRAINT anidetailxref_individual_fk FOREIGN KEY ( indiv_id )
        REFERENCES individual ( indiv_id );

ALTER TABLE anidetailxref
    ADD CONSTRAINT anidetailxref_indtreat_fk FOREIGN KEY ( ind_treatment_id )
        REFERENCES indtreatment ( ind_treatment_id );

ALTER TABLE anidetailxref
    ADD CONSTRAINT anidetailxref_location_fk FOREIGN KEY ( location_id )
        REFERENCES location ( location_id );

ALTER TABLE anidetailxref
    ADD CONSTRAINT anidetailxref_spawning_fk FOREIGN KEY ( spawn_id )
        REFERENCES spawning ( spawn_id );

ALTER TABLE anidetsubjcode
    ADD CONSTRAINT anidetsubj_animaldet_fk FOREIGN KEY ( ani_det_id )
        REFERENCES animaldetcode ( ani_det_id );

ALTER TABLE animaldetcode
    ADD CONSTRAINT animaldetcode_unitcode_fk FOREIGN KEY ( unit_id )
        REFERENCES unitcode ( unit_id );

ALTER TABLE containerdetcode
    ADD CONSTRAINT containerdetcode_unitcode_fk FOREIGN KEY ( unit_id )
        REFERENCES unitcode ( unit_id );

ALTER TABLE containerxref
    ADD CONSTRAINT containerxref_cup_fk FOREIGN KEY ( cup_id )
        REFERENCES cup ( cup_id );

ALTER TABLE containerxref
    ADD CONSTRAINT containerxref_drawer_fk FOREIGN KEY ( drawer_id )
        REFERENCES drawer ( drawer_id );

ALTER TABLE containerxref
    ADD CONSTRAINT containerxref_event_fk FOREIGN KEY ( event_id )
        REFERENCES event ( event_id );

ALTER TABLE containerxref
    ADD CONSTRAINT containerxref_heathunit_fk FOREIGN KEY ( heath_unit_id )
        REFERENCES heathunit ( heath_unit_id );

ALTER TABLE containerxref
    ADD CONSTRAINT containerxref_tank_fk FOREIGN KEY ( tank_id )
        REFERENCES tank ( tank_id );

ALTER TABLE containerxref
    ADD CONSTRAINT containerxref_tray_fk FOREIGN KEY ( tray_id )
        REFERENCES tray ( tray_id );

ALTER TABLE containerxref
    ADD CONSTRAINT containerxref_trough_fk FOREIGN KEY ( trough_id )
        REFERENCES trough ( trough_id );

ALTER TABLE contdetsubjcode
    ADD CONSTRAINT contdetsubj_containerdet_fk FOREIGN KEY ( cont_det_id )
        REFERENCES containerdetcode ( cont_det_id );

ALTER TABLE count
    ADD CONSTRAINT count_containerxref_fk FOREIGN KEY ( container_xref_id )
        REFERENCES containerxref ( container_xref_id );

ALTER TABLE count
    ADD CONSTRAINT count_countcode_fk FOREIGN KEY ( cnt_id )
        REFERENCES countcode ( cnt_id );

ALTER TABLE count
    ADD CONSTRAINT count_location_fk FOREIGN KEY ( location_id )
        REFERENCES location ( location_id );

ALTER TABLE count
    ADD CONSTRAINT count_speciescode_fk FOREIGN KEY ( spec_id )
        REFERENCES speciescode ( spec_id );

ALTER TABLE countdet
    ADD CONSTRAINT countdet_anidetsubjcode_fk FOREIGN KEY ( ani_det_subj_id )
        REFERENCES anidetsubjcode ( ani_det_subj_id );

ALTER TABLE countdet
    ADD CONSTRAINT countdet_animaldetcode_fk FOREIGN KEY ( ani_det_id )
        REFERENCES animaldetcode ( ani_det_id );

ALTER TABLE countdet
    ADD CONSTRAINT countdet_count_fk FOREIGN KEY ( count_id )
        REFERENCES count ( count_id );

ALTER TABLE countdet
    ADD CONSTRAINT countdet_qualcode_fk FOREIGN KEY ( qual_id )
        REFERENCES qualcode ( qual_id );

ALTER TABLE cupdet
    ADD CONSTRAINT cupdet_containerdetcode_fk FOREIGN KEY ( cont_det_id )
        REFERENCES containerdetcode ( cont_det_id );

ALTER TABLE cupdet
    ADD CONSTRAINT cupdet_contdetsubjcode_fk FOREIGN KEY ( cont_det_subj_id )
        REFERENCES contdetsubjcode ( cont_det_subj_id );

ALTER TABLE cupdet
    ADD CONSTRAINT cupdet_cup_fk FOREIGN KEY ( cup_id )
        REFERENCES cup ( cup_id );

ALTER TABLE envcode
    ADD CONSTRAINT envcode_unitcode_fk FOREIGN KEY ( unit_id )
        REFERENCES unitcode ( unit_id );

ALTER TABLE envcondfile
    ADD CONSTRAINT envcondfile_envcondition_fk FOREIGN KEY ( env_cond_id )
        REFERENCES envcondition ( env_cond_id );

ALTER TABLE envcondition
    ADD CONSTRAINT envcondition_contxref_fk FOREIGN KEY ( container_xref_id )
        REFERENCES containerxref ( container_xref_id );

ALTER TABLE envcondition
    ADD CONSTRAINT envcondition_envcode_fk FOREIGN KEY ( env_id )
        REFERENCES envcode ( env_id );

ALTER TABLE envcondition
    ADD CONSTRAINT envcondition_envsubjcode_fk FOREIGN KEY ( env_subj_id )
        REFERENCES envsubjcode ( env_subj_id );

ALTER TABLE envcondition
    ADD CONSTRAINT envcondition_instrument_fk FOREIGN KEY ( instrum_id )
        REFERENCES instrument ( instrum_id );

ALTER TABLE envcondition
    ADD CONSTRAINT envcondition_location_fk FOREIGN KEY ( location_id )
        REFERENCES location ( location_id );

ALTER TABLE envcondition
    ADD CONSTRAINT envcondition_qualcode_fk FOREIGN KEY ( qual_id )
        REFERENCES qualcode ( qual_id );

ALTER TABLE envsubjcode
    ADD CONSTRAINT envsubjcode_envcode_fk FOREIGN KEY ( env_id )
        REFERENCES envcode ( env_id );

ALTER TABLE envtreatment
    ADD CONSTRAINT envtreatment_contxref_fk FOREIGN KEY ( container_xref_id )
        REFERENCES containerxref ( container_xref_id );

ALTER TABLE event
    ADD CONSTRAINT event_eventcode_fk FOREIGN KEY ( evt_id )
        REFERENCES eventcode ( evt_id );

ALTER TABLE event
    ADD CONSTRAINT event_facility_fk FOREIGN KEY ( fac_id )
        REFERENCES facilitycode ( fac_id );

ALTER TABLE event
    ADD CONSTRAINT event_personnelcode_fk FOREIGN KEY ( per_id )
        REFERENCES personnelcode ( per_id );

ALTER TABLE event
    ADD CONSTRAINT event_program_fk FOREIGN KEY ( program_id )
        REFERENCES program ( program_id );

ALTER TABLE event
    ADD CONSTRAINT event_team_fk FOREIGN KEY ( team_id )
        REFERENCES team ( team_id );

ALTER TABLE fecundity
    ADD CONSTRAINT fecundity_collection_fk FOREIGN KEY ( collection_id )
        REFERENCES collection ( collection_id );

ALTER TABLE fecundity
    ADD CONSTRAINT fecundity_stockcode_fk FOREIGN KEY ( stock_id )
        REFERENCES stockcode ( stock_id );

ALTER TABLE feeding
    ADD CONSTRAINT feeding_containerxref_fk FOREIGN KEY ( container_xref_id )
        REFERENCES containerxref ( container_xref_id );

ALTER TABLE feeding
    ADD CONSTRAINT feeding_feedcode_fk FOREIGN KEY ( feed_id )
        REFERENCES feedcode ( feed_id );

ALTER TABLE feeding
    ADD CONSTRAINT feeding_feedmethod_fk FOREIGN KEY ( feedmethod_id )
        REFERENCES feedmethod ( feedmethod_id );

ALTER TABLE feeding
    ADD CONSTRAINT feeding_unitcode_fk FOREIGN KEY ( unit_id )
        REFERENCES unitcode ( unit_id );

ALTER TABLE "GROUP"
    ADD CONSTRAINT group_collection_fk FOREIGN KEY ( collection_id )
        REFERENCES collection ( collection_id );

ALTER TABLE "GROUP"
    ADD CONSTRAINT group_group_fk FOREIGN KEY ( from_group_id )
        REFERENCES "GROUP" ( group_id );

ALTER TABLE "GROUP"
    ADD CONSTRAINT group_speciescode_fk FOREIGN KEY ( spec_id )
        REFERENCES speciescode ( spec_id );

ALTER TABLE "GROUP"
    ADD CONSTRAINT group_stockcode_fk FOREIGN KEY ( stock_id )
        REFERENCES stockcode ( stock_id );

ALTER TABLE groupdet
    ADD CONSTRAINT groupdet_anidetailxref_fk FOREIGN KEY ( ani_det_xref_id )
        REFERENCES anidetailxref ( ani_det_xref_id );

ALTER TABLE groupdet
    ADD CONSTRAINT groupdet_anidetsubjcode_fk FOREIGN KEY ( ani_det_subj_id )
        REFERENCES anidetsubjcode ( ani_det_subj_id );

ALTER TABLE groupdet
    ADD CONSTRAINT groupdet_animaldetcode_fk FOREIGN KEY ( ani_det_id )
        REFERENCES animaldetcode ( ani_det_id );

ALTER TABLE groupdet
    ADD CONSTRAINT groupdet_qualcode_fk FOREIGN KEY ( qual_id )
        REFERENCES qualcode ( qual_id );

ALTER TABLE heathunitdet
    ADD CONSTRAINT heathunitdet_containerdet_fk FOREIGN KEY ( cont_det_id )
        REFERENCES containerdetcode ( cont_det_id );

ALTER TABLE heathunitdet
    ADD CONSTRAINT heathunitdet_contdetsubj_fk FOREIGN KEY ( cont_det_subj_id )
        REFERENCES contdetsubjcode ( cont_det_subj_id );

ALTER TABLE heathunitdet
    ADD CONSTRAINT heathunitdet_heathunit_fk FOREIGN KEY ( heath_unit_id )
        REFERENCES heathunit ( heath_unit_id );

ALTER TABLE image
    ADD CONSTRAINT image_countdet_fk FOREIGN KEY ( count_det_id )
        REFERENCES countdet ( count_det_id );

ALTER TABLE image
    ADD CONSTRAINT image_cupdet_fk FOREIGN KEY ( cup_det_id )
        REFERENCES cupdet ( cup_det_id );

ALTER TABLE image
    ADD CONSTRAINT image_drawer_fk FOREIGN KEY ( drawer_id )
        REFERENCES drawer ( drawer_id );

ALTER TABLE image
    ADD CONSTRAINT image_groupdet_fk FOREIGN KEY ( group_det_id )
        REFERENCES groupdet ( group_det_id );

ALTER TABLE image
    ADD CONSTRAINT image_heathunitdet_fk FOREIGN KEY ( heath_unit_det_id )
        REFERENCES heathunitdet ( heath_unit_det_id );

ALTER TABLE image
    ADD CONSTRAINT image_imagecode_fk FOREIGN KEY ( img_id )
        REFERENCES imagecode ( img_id );

ALTER TABLE image
    ADD CONSTRAINT image_individualdet_fk FOREIGN KEY ( indiv_det_id )
        REFERENCES individualdet ( indiv_det_id );

ALTER TABLE image
    ADD CONSTRAINT image_location_fk FOREIGN KEY ( location_id )
        REFERENCES location ( location_id );

ALTER TABLE image
    ADD CONSTRAINT image_sampledet_fk FOREIGN KEY ( samp_det_id )
        REFERENCES sampledet ( samp_det_id );

ALTER TABLE image
    ADD CONSTRAINT image_spawndet_fk FOREIGN KEY ( spawn_detail_id )
        REFERENCES spawndet ( spawn_detail_id );

ALTER TABLE image
    ADD CONSTRAINT image_tankdet_fk FOREIGN KEY ( tank_det_id )
        REFERENCES tankdet ( tank_det_id );

ALTER TABLE image
    ADD CONSTRAINT image_traydet_fk FOREIGN KEY ( tray_det_id )
        REFERENCES traydet ( tray_det_id );

ALTER TABLE image
    ADD CONSTRAINT image_troughdet_fk FOREIGN KEY ( trough_det_id )
        REFERENCES troughdet ( trough_det_id );

ALTER TABLE individual
    ADD CONSTRAINT individual_collection_fk FOREIGN KEY ( collection_id )
        REFERENCES collection ( collection_id );

ALTER TABLE individual
    ADD CONSTRAINT individual_group_fk FOREIGN KEY ( group_id )
        REFERENCES "GROUP" ( group_id );

ALTER TABLE individual
    ADD CONSTRAINT individual_speciescode_fk FOREIGN KEY ( spec_id )
        REFERENCES speciescode ( spec_id );

ALTER TABLE individual
    ADD CONSTRAINT individual_stockcode_fk FOREIGN KEY ( stock_id )
        REFERENCES stockcode ( stock_id );

ALTER TABLE individualdet
    ADD CONSTRAINT individualdet_anidetsubj_fk FOREIGN KEY ( ani_det_subj_id )
        REFERENCES anidetsubjcode ( ani_det_subj_id );

ALTER TABLE individualdet
    ADD CONSTRAINT individualdet_anidetxref_fk FOREIGN KEY ( ani_det_xref_id )
        REFERENCES anidetailxref ( ani_det_xref_id );

ALTER TABLE individualdet
    ADD CONSTRAINT individualdet_animaldet_fk FOREIGN KEY ( ani_det_id )
        REFERENCES animaldetcode ( ani_det_id );

ALTER TABLE individualdet
    ADD CONSTRAINT individualdet_qualcode_fk FOREIGN KEY ( qual_id )
        REFERENCES qualcode ( qual_id );

ALTER TABLE indtreatment
    ADD CONSTRAINT indtreatment_indtreat_fk FOREIGN KEY ( ind_treat_id )
        REFERENCES indtreatcode ( ind_treat_id );

ALTER TABLE instrument
    ADD CONSTRAINT instrument_instrumentcode_fk FOREIGN KEY ( inst_id )
        REFERENCES instrumentcode ( inst_id );

ALTER TABLE instrumentdet
    ADD CONSTRAINT instrumentdet_instdetcode_fk FOREIGN KEY ( inst_det_id )
        REFERENCES instdetcode ( inst_det_id );

ALTER TABLE instrumentdet
    ADD CONSTRAINT instrumentdet_instrument_fk FOREIGN KEY ( instrum_id )
        REFERENCES instrument ( instrum_id );

ALTER TABLE location
    ADD CONSTRAINT location_event_fk FOREIGN KEY ( event_id )
        REFERENCES event ( event_id );

ALTER TABLE location
    ADD CONSTRAINT location_loccode_fk FOREIGN KEY ( loc_id )
        REFERENCES loccode ( loc_id );

ALTER TABLE location
    ADD CONSTRAINT location_releasesitecode_fk FOREIGN KEY ( rel_site_id )
        REFERENCES releasesitecode ( rel_site_id );

ALTER TABLE location
    ADD CONSTRAINT location_rivercode_fk FOREIGN KEY ( river_id )
        REFERENCES rivercode ( river_id );

ALTER TABLE location
    ADD CONSTRAINT location_subrivercode_fk FOREIGN KEY ( subriver_id )
        REFERENCES subrivercode ( subriver_id );

ALTER TABLE location
    ADD CONSTRAINT location_tributary_fk FOREIGN KEY ( trib_id )
        REFERENCES tributary ( trib_id );

ALTER TABLE matingplan
    ADD CONSTRAINT matingplan_event_fk FOREIGN KEY ( event_id )
        REFERENCES event ( event_id );

ALTER TABLE pairing
    ADD CONSTRAINT pairing_individual_dam_fk FOREIGN KEY ( dam )
        REFERENCES individual ( ufid );

ALTER TABLE program
    ADD CONSTRAINT program_organization_fk FOREIGN KEY ( org_id )
        REFERENCES organization ( org_id );

ALTER TABLE program
    ADD CONSTRAINT program_progauthority_fk FOREIGN KEY ( prog_auth_id )
        REFERENCES progauthority ( prog_auth_id );

ALTER TABLE protocol
    ADD CONSTRAINT protocol_program_fk FOREIGN KEY ( program_id )
        REFERENCES program ( program_id );

ALTER TABLE protocol
    ADD CONSTRAINT protocol_protocode_fk FOREIGN KEY ( proto_id )
        REFERENCES protocode ( proto_id );

ALTER TABLE protocol
    ADD CONSTRAINT protocol_protofile_fk FOREIGN KEY ( proto_file_id )
        REFERENCES protofile ( proto_file_id );

ALTER TABLE releasesitecode
    ADD CONSTRAINT releasesite_rivercode_fk FOREIGN KEY ( river_id )
        REFERENCES rivercode ( river_id );

ALTER TABLE releasesitecode
    ADD CONSTRAINT releasesite_subrivercode_fk FOREIGN KEY ( subriver_id )
        REFERENCES subrivercode ( subriver_id );

ALTER TABLE releasesitecode
    ADD CONSTRAINT releasesite_tributary_fk FOREIGN KEY ( trib_id )
        REFERENCES tributary ( trib_id );

ALTER TABLE sample
    ADD CONSTRAINT sample_location_fk FOREIGN KEY ( location_id )
        REFERENCES location ( location_id );

ALTER TABLE sample
    ADD CONSTRAINT sample_samplecode_fk FOREIGN KEY ( samp_id )
        REFERENCES samplecode ( samp_id );

ALTER TABLE sample
    ADD CONSTRAINT sample_speciescode_fk FOREIGN KEY ( spec_id )
        REFERENCES speciescode ( spec_id );

ALTER TABLE sampledet
    ADD CONSTRAINT sampledet_anidetsubjcode_fk FOREIGN KEY ( ani_det_subj_id )
        REFERENCES anidetsubjcode ( ani_det_subj_id );

ALTER TABLE sampledet
    ADD CONSTRAINT sampledet_animaldetcode_fk FOREIGN KEY ( ani_det_id )
        REFERENCES animaldetcode ( ani_det_id );

ALTER TABLE sampledet
    ADD CONSTRAINT sampledet_qualcode_fk FOREIGN KEY ( qual_id )
        REFERENCES qualcode ( qual_id );

ALTER TABLE sampledet
    ADD CONSTRAINT sampledet_sample_fk FOREIGN KEY ( sample_id )
        REFERENCES sample ( sample_id );

ALTER TABLE sire
    ADD CONSTRAINT sire_individual_fk FOREIGN KEY ( ufid )
        REFERENCES individual ( ufid );

ALTER TABLE sire
    ADD CONSTRAINT sire_pairing_fk FOREIGN KEY ( pair_id )
        REFERENCES pairing ( pair_id );

ALTER TABLE sire
    ADD CONSTRAINT sire_prioritycode_fk FOREIGN KEY ( priority_id )
        REFERENCES prioritycode ( priority_id );

ALTER TABLE spawndet
    ADD CONSTRAINT spawndet_qualcode_fk FOREIGN KEY ( qual_id )
        REFERENCES qualcode ( qual_id );

ALTER TABLE spawndet
    ADD CONSTRAINT spawndet_spawndetcode_fk FOREIGN KEY ( spawn_det_id )
        REFERENCES spawndetcode ( spawn_det_id );

ALTER TABLE spawndet
    ADD CONSTRAINT spawndet_spawndetsubjcode_fk FOREIGN KEY ( spawn_det_subj_id )
        REFERENCES spawndetsubjcode ( spawn_det_subj_id );

ALTER TABLE spawndetcode
    ADD CONSTRAINT spawndetcode_unit_fk FOREIGN KEY ( unit_id )
        REFERENCES unitcode ( unit_id );

ALTER TABLE spawndetsubjcode
    ADD CONSTRAINT spawndetsubj_spawndet_fk FOREIGN KEY ( spawn_det_id )
        REFERENCES spawndetcode ( spawn_det_id );

ALTER TABLE spawning
    ADD CONSTRAINT spawning_pairing_fk FOREIGN KEY ( pair_id )
        REFERENCES pairing ( pair_id );

ALTER TABLE spawndet
    ADD CONSTRAINT spawningdet_spawning_fk FOREIGN KEY ( spawn_id )
        REFERENCES spawning ( spawn_id );

ALTER TABLE subrivercode
    ADD CONSTRAINT subriver_rivercode_fk FOREIGN KEY ( river_id )
        REFERENCES rivercode ( river_id );

ALTER TABLE subrivercode
    ADD CONSTRAINT subrivercode_tributary_fk FOREIGN KEY ( trib_id )
        REFERENCES tributary ( trib_id );

ALTER TABLE tankdet
    ADD CONSTRAINT tankdet_containerdetcode_fk FOREIGN KEY ( cont_det_id )
        REFERENCES containerdetcode ( cont_det_id );

ALTER TABLE tankdet
    ADD CONSTRAINT tankdet_contdetsubjcode_fk FOREIGN KEY ( cont_det_subj_id )
        REFERENCES contdetsubjcode ( cont_det_subj_id );

ALTER TABLE tankdet
    ADD CONSTRAINT tankdet_tank_fk FOREIGN KEY ( tank_id )
        REFERENCES tank ( tank_id );

ALTER TABLE team
    ADD CONSTRAINT team_personnelcode_fk FOREIGN KEY ( per_id )
        REFERENCES personnelcode ( per_id );

ALTER TABLE team
    ADD CONSTRAINT team_rolecode_fk FOREIGN KEY ( role_id )
        REFERENCES rolecode ( role_id );

ALTER TABLE traydet
    ADD CONSTRAINT traydet_containerdetcode_fk FOREIGN KEY ( cont_det_id )
        REFERENCES containerdetcode ( cont_det_id );

ALTER TABLE traydet
    ADD CONSTRAINT traydet_contdetsubjcode_fk FOREIGN KEY ( cont_det_subj_id )
        REFERENCES contdetsubjcode ( cont_det_subj_id );

ALTER TABLE traydet
    ADD CONSTRAINT traydet_tray_fk FOREIGN KEY ( tray_id )
        REFERENCES tray ( tray_id );

ALTER TABLE envtreatment
    ADD CONSTRAINT treatment_envtreatcode_fk FOREIGN KEY ( env_treat_id )
        REFERENCES envtreatmentcode ( env_treat_id );

ALTER TABLE envtreatment
    ADD CONSTRAINT treatment_unitcode_fk FOREIGN KEY ( unit_id )
        REFERENCES unitcode ( unit_id );

ALTER TABLE tributary
    ADD CONSTRAINT tributary_rivercode_fk FOREIGN KEY ( river_id )
        REFERENCES rivercode ( river_id );

ALTER TABLE troughdet
    ADD CONSTRAINT troughdet_contdetcode_fk FOREIGN KEY ( cont_det_id )
        REFERENCES containerdetcode ( cont_det_id );

ALTER TABLE troughdet
    ADD CONSTRAINT troughdet_contdetsubjcode_fk FOREIGN KEY ( cont_det_subj_id )
        REFERENCES contdetsubjcode ( cont_det_subj_id );

ALTER TABLE troughdet
    ADD CONSTRAINT troughdet_trough_fk FOREIGN KEY ( trough_id )
        REFERENCES trough ( trough_id );

CREATE SEQUENCE anidetsubjcode_ani_det_subj_id START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER anidetsubjcode_ani_det_subj_id BEFORE
    INSERT ON anidetsubjcode
    FOR EACH ROW
    WHEN ( new.ani_det_subj_id IS NULL )
BEGIN
    :new.ani_det_subj_id := anidetsubjcode_ani_det_subj_id.nextval;
END;
/

CREATE SEQUENCE animaldetcode_ani_det_id_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER animaldetcode_ani_det_id_trg BEFORE
    INSERT ON animaldetcode
    FOR EACH ROW
    WHEN ( new.ani_det_id IS NULL )
BEGIN
    :new.ani_det_id := animaldetcode_ani_det_id_seq.nextval;
END;
/

CREATE SEQUENCE collection_collection_id_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER collection_collection_id_trg BEFORE
    INSERT ON collection
    FOR EACH ROW
    WHEN ( new.collection_id IS NULL )
BEGIN
    :new.collection_id := collection_collection_id_seq.nextval;
END;
/

CREATE SEQUENCE containerdetcode_cont_det_id START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER containerdetcode_cont_det_id BEFORE
    INSERT ON containerdetcode
    FOR EACH ROW
    WHEN ( new.cont_det_id IS NULL )
BEGIN
    :new.cont_det_id := containerdetcode_cont_det_id.nextval;
END;
/

CREATE SEQUENCE contdetsubjcode_cont_det_subj_ START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER contdetsubjcode_cont_det_subj_ BEFORE
    INSERT ON contdetsubjcode
    FOR EACH ROW
    WHEN ( new.cont_det_subj_id IS NULL )
BEGIN
    :new.cont_det_subj_id := contdetsubjcode_cont_det_subj_.nextval;
END;
/

CREATE SEQUENCE count_count_id_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER count_count_id_trg BEFORE
    INSERT ON count
    FOR EACH ROW
    WHEN ( new.count_id IS NULL )
BEGIN
    :new.count_id := count_count_id_seq.nextval;
END;
/

CREATE SEQUENCE countcode_cnt_id_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER countcode_cnt_id_trg BEFORE
    INSERT ON countcode
    FOR EACH ROW
    WHEN ( new.cnt_id IS NULL )
BEGIN
    :new.cnt_id := countcode_cnt_id_seq.nextval;
END;
/

CREATE SEQUENCE countdet_count_det_id_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER countdet_count_det_id_trg BEFORE
    INSERT ON countdet
    FOR EACH ROW
    WHEN ( new.count_det_id IS NULL )
BEGIN
    :new.count_det_id := countdet_count_det_id_seq.nextval;
END;
/

CREATE SEQUENCE cup_cup_id_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER cup_cup_id_trg BEFORE
    INSERT ON cup
    FOR EACH ROW
    WHEN ( new.cup_id IS NULL )
BEGIN
    :new.cup_id := cup_cup_id_seq.nextval;
END;
/

CREATE SEQUENCE cupdet_cup_det_id_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER cupdet_cup_det_id_trg BEFORE
    INSERT ON cupdet
    FOR EACH ROW
    WHEN ( new.cup_det_id IS NULL )
BEGIN
    :new.cup_det_id := cupdet_cup_det_id_seq.nextval;
END;
/

CREATE SEQUENCE drawer_drawer_id_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER drawer_drawer_id_trg BEFORE
    INSERT ON drawer
    FOR EACH ROW
    WHEN ( new.drawer_id IS NULL )
BEGIN
    :new.drawer_id := drawer_drawer_id_seq.nextval;
END;
/

CREATE SEQUENCE envcode_env_id_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER envcode_env_id_trg BEFORE
    INSERT ON envcode
    FOR EACH ROW
    WHEN ( new.env_id IS NULL )
BEGIN
    :new.env_id := envcode_env_id_seq.nextval;
END;
/

CREATE SEQUENCE envcondfile_env_cond_file_id START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER envcondfile_env_cond_file_id BEFORE
    INSERT ON envcondfile
    FOR EACH ROW
    WHEN ( new.env_cond_file_id IS NULL )
BEGIN
    :new.env_cond_file_id := envcondfile_env_cond_file_id.nextval;
END;
/

CREATE SEQUENCE envcondition_env_cond_id_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER envcondition_env_cond_id_trg BEFORE
    INSERT ON envcondition
    FOR EACH ROW
    WHEN ( new.env_cond_id IS NULL )
BEGIN
    :new.env_cond_id := envcondition_env_cond_id_seq.nextval;
END;
/

CREATE SEQUENCE envsubjcode_env_subj_id_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER envsubjcode_env_subj_id_trg BEFORE
    INSERT ON envsubjcode
    FOR EACH ROW
    WHEN ( new.env_subj_id IS NULL )
BEGIN
    :new.env_subj_id := envsubjcode_env_subj_id_seq.nextval;
END;
/

CREATE SEQUENCE envtreatment_env_treatment_id START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER envtreatment_env_treatment_id BEFORE
    INSERT ON envtreatment
    FOR EACH ROW
    WHEN ( new.env_treatment_id IS NULL )
BEGIN
    :new.env_treatment_id := envtreatment_env_treatment_id.nextval;
END;
/

CREATE SEQUENCE envtreatmentcode_env_treat_id START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER envtreatmentcode_env_treat_id BEFORE
    INSERT ON envtreatmentcode
    FOR EACH ROW
    WHEN ( new.env_treat_id IS NULL )
BEGIN
    :new.env_treat_id := envtreatmentcode_env_treat_id.nextval;
END;
/

CREATE SEQUENCE event_event_id_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER event_event_id_trg BEFORE
    INSERT ON event
    FOR EACH ROW
    WHEN ( new.event_id IS NULL )
BEGIN
    :new.event_id := event_event_id_seq.nextval;
END;
/

CREATE SEQUENCE eventcode_evt_id_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER eventcode_evt_id_trg BEFORE
    INSERT ON eventcode
    FOR EACH ROW
    WHEN ( new.evt_id IS NULL )
BEGIN
    :new.evt_id := eventcode_evt_id_seq.nextval;
END;
/

CREATE SEQUENCE facilitycode_fac_id_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER facilitycode_fac_id_trg BEFORE
    INSERT ON facilitycode
    FOR EACH ROW
    WHEN ( new.fac_id IS NULL )
BEGIN
    :new.fac_id := facilitycode_fac_id_seq.nextval;
END;
/

CREATE SEQUENCE fecundity_fec_id_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER fecundity_fec_id_trg BEFORE
    INSERT ON fecundity
    FOR EACH ROW
    WHEN ( new.fec_id IS NULL )
BEGIN
    :new.fec_id := fecundity_fec_id_seq.nextval;
END;
/

CREATE SEQUENCE feedcode_feed_id_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER feedcode_feed_id_trg BEFORE
    INSERT ON feedcode
    FOR EACH ROW
    WHEN ( new.feed_id IS NULL )
BEGIN
    :new.feed_id := feedcode_feed_id_seq.nextval;
END;
/

CREATE SEQUENCE feeding_feeding_id_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER feeding_feeding_id_trg BEFORE
    INSERT ON feeding
    FOR EACH ROW
    WHEN ( new.feeding_id IS NULL )
BEGIN
    :new.feeding_id := feeding_feeding_id_seq.nextval;
END;
/

CREATE SEQUENCE feedmethod_feedmethod_id_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER feedmethod_feedmethod_id_trg BEFORE
    INSERT ON feedmethod
    FOR EACH ROW
    WHEN ( new.feedmethod_id IS NULL )
BEGIN
    :new.feedmethod_id := feedmethod_feedmethod_id_seq.nextval;
END;
/

CREATE SEQUENCE group_group_id_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER group_group_id_trg BEFORE
    INSERT ON "GROUP"
    FOR EACH ROW
    WHEN ( new.group_id IS NULL )
BEGIN
    :new.group_id := group_group_id_seq.nextval;
END;
/

CREATE SEQUENCE groupdet_group_det_id_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER groupdet_group_det_id_trg BEFORE
    INSERT ON groupdet
    FOR EACH ROW
    WHEN ( new.group_det_id IS NULL )
BEGIN
    :new.group_det_id := groupdet_group_det_id_seq.nextval;
END;
/

CREATE SEQUENCE heathunit_heath_unit_id_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER heathunit_heath_unit_id_trg BEFORE
    INSERT ON heathunit
    FOR EACH ROW
    WHEN ( new.heath_unit_id IS NULL )
BEGIN
    :new.heath_unit_id := heathunit_heath_unit_id_seq.nextval;
END;
/

CREATE SEQUENCE heathunitdet_heath_unit_det_id START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER heathunitdet_heath_unit_det_id BEFORE
    INSERT ON heathunitdet
    FOR EACH ROW
    WHEN ( new.heath_unit_det_id IS NULL )
BEGIN
    :new.heath_unit_det_id := heathunitdet_heath_unit_det_id.nextval;
END;
/

CREATE SEQUENCE image_image_id_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER image_image_id_trg BEFORE
    INSERT ON image
    FOR EACH ROW
    WHEN ( new.image_id IS NULL )
BEGIN
    :new.image_id := image_image_id_seq.nextval;
END;
/

CREATE SEQUENCE imagecode_img_id_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER imagecode_img_id_trg BEFORE
    INSERT ON imagecode
    FOR EACH ROW
    WHEN ( new.img_id IS NULL )
BEGIN
    :new.img_id := imagecode_img_id_seq.nextval;
END;
/

CREATE SEQUENCE individual_indiv_id_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER individual_indiv_id_trg BEFORE
    INSERT ON individual
    FOR EACH ROW
    WHEN ( new.indiv_id IS NULL )
BEGIN
    :new.indiv_id := individual_indiv_id_seq.nextval;
END;
/

CREATE SEQUENCE individualdet_indiv_det_id_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER individualdet_indiv_det_id_trg BEFORE
    INSERT ON individualdet
    FOR EACH ROW
    WHEN ( new.indiv_det_id IS NULL )
BEGIN
    :new.indiv_det_id := individualdet_indiv_det_id_seq.nextval;
END;
/

CREATE SEQUENCE indtreatcode_ind_treat_id_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER indtreatcode_ind_treat_id_trg BEFORE
    INSERT ON indtreatcode
    FOR EACH ROW
    WHEN ( new.ind_treat_id IS NULL )
BEGIN
    :new.ind_treat_id := indtreatcode_ind_treat_id_seq.nextval;
END;
/

CREATE SEQUENCE indtreatment_ind_treatment_id START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER indtreatment_ind_treatment_id BEFORE
    INSERT ON indtreatment
    FOR EACH ROW
    WHEN ( new.ind_treatment_id IS NULL )
BEGIN
    :new.ind_treatment_id := indtreatment_ind_treatment_id.nextval;
END;
/

CREATE SEQUENCE instdetcode_inst_det_id_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER instdetcode_inst_det_id_trg BEFORE
    INSERT ON instdetcode
    FOR EACH ROW
    WHEN ( new.inst_det_id IS NULL )
BEGIN
    :new.inst_det_id := instdetcode_inst_det_id_seq.nextval;
END;
/

CREATE SEQUENCE instrument_instrum_id_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER instrument_instrum_id_trg BEFORE
    INSERT ON instrument
    FOR EACH ROW
    WHEN ( new.instrum_id IS NULL )
BEGIN
    :new.instrum_id := instrument_instrum_id_seq.nextval;
END;
/

CREATE SEQUENCE instrumentcode_inst_id_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER instrumentcode_inst_id_trg BEFORE
    INSERT ON instrumentcode
    FOR EACH ROW
    WHEN ( new.inst_id IS NULL )
BEGIN
    :new.inst_id := instrumentcode_inst_id_seq.nextval;
END;
/

CREATE SEQUENCE instrumentdet_instrum_det_id START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER instrumentdet_instrum_det_id BEFORE
    INSERT ON instrumentdet
    FOR EACH ROW
    WHEN ( new.instrum_det_id IS NULL )
BEGIN
    :new.instrum_det_id := instrumentdet_instrum_det_id.nextval;
END;
/

CREATE SEQUENCE location_location_id_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER location_location_id_trg BEFORE
    INSERT ON location
    FOR EACH ROW
    WHEN ( new.location_id IS NULL )
BEGIN
    :new.location_id := location_location_id_seq.nextval;
END;
/

CREATE SEQUENCE loccode_loc_id_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER loccode_loc_id_trg BEFORE
    INSERT ON loccode
    FOR EACH ROW
    WHEN ( new.loc_id IS NULL )
BEGIN
    :new.loc_id := loccode_loc_id_seq.nextval;
END;
/

CREATE SEQUENCE organization_org_id_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER organization_org_id_trg BEFORE
    INSERT ON organization
    FOR EACH ROW
    WHEN ( new.org_id IS NULL )
BEGIN
    :new.org_id := organization_org_id_seq.nextval;
END;
/

CREATE SEQUENCE pairing_pair_id_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER pairing_pair_id_trg BEFORE
    INSERT ON pairing
    FOR EACH ROW
    WHEN ( new.pair_id IS NULL )
BEGIN
    :new.pair_id := pairing_pair_id_seq.nextval;
END;
/

CREATE SEQUENCE per_per_id_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER per_per_id_trg BEFORE
    INSERT ON personnelcode
    FOR EACH ROW
    WHEN ( new.per_id IS NULL )
BEGIN
    :new.per_id := per_per_id_seq.nextval;
END;
/

CREATE SEQUENCE progauthority_prog_auth_id_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER progauthority_prog_auth_id_trg BEFORE
    INSERT ON progauthority
    FOR EACH ROW
    WHEN ( new.prog_auth_id IS NULL )
BEGIN
    :new.prog_auth_id := progauthority_prog_auth_id_seq.nextval;
END;
/

CREATE SEQUENCE program_id_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER program_id_trg BEFORE
    INSERT ON program
    FOR EACH ROW
    WHEN ( new.program_id IS NULL )
BEGIN
    :new.program_id := program_id_seq.nextval;
END;
/

CREATE SEQUENCE proto_id_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER proto_id_trg BEFORE
    INSERT ON protocode
    FOR EACH ROW
    WHEN ( new.proto_id IS NULL )
BEGIN
    :new.proto_id := proto_id_seq.nextval;
END;
/

CREATE SEQUENCE protocol_protocol_id_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER protocol_protocol_id_trg BEFORE
    INSERT ON protocol
    FOR EACH ROW
    WHEN ( new.protocol_id IS NULL )
BEGIN
    :new.protocol_id := protocol_protocol_id_seq.nextval;
END;
/

CREATE SEQUENCE protofile_proto_file_id_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER protofile_proto_file_id_trg BEFORE
    INSERT ON protofile
    FOR EACH ROW
    WHEN ( new.proto_file_id IS NULL )
BEGIN
    :new.proto_file_id := protofile_proto_file_id_seq.nextval;
END;
/

CREATE SEQUENCE qualcode_qual_id_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER qualcode_qual_id_trg BEFORE
    INSERT ON qualcode
    FOR EACH ROW
    WHEN ( new.qual_id IS NULL )
BEGIN
    :new.qual_id := qualcode_qual_id_seq.nextval;
END;
/

CREATE SEQUENCE releasesitecode_rel_site_id START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER releasesitecode_rel_site_id BEFORE
    INSERT ON releasesitecode
    FOR EACH ROW
    WHEN ( new.rel_site_id IS NULL )
BEGIN
    :new.rel_site_id := releasesitecode_rel_site_id.nextval;
END;
/

CREATE SEQUENCE rivercode_river_id_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER rivercode_river_id_trg BEFORE
    INSERT ON rivercode
    FOR EACH ROW
    WHEN ( new.river_id IS NULL )
BEGIN
    :new.river_id := rivercode_river_id_seq.nextval;
END;
/

CREATE SEQUENCE rolecode_role_id_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER rolecode_role_id_trg BEFORE
    INSERT ON rolecode
    FOR EACH ROW
    WHEN ( new.role_id IS NULL )
BEGIN
    :new.role_id := rolecode_role_id_seq.nextval;
END;
/

CREATE SEQUENCE sample_sample_id_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER sample_sample_id_trg BEFORE
    INSERT ON sample
    FOR EACH ROW
    WHEN ( new.sample_id IS NULL )
BEGIN
    :new.sample_id := sample_sample_id_seq.nextval;
END;
/

CREATE SEQUENCE samplecode_samp_id_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER samplecode_samp_id_trg BEFORE
    INSERT ON samplecode
    FOR EACH ROW
    WHEN ( new.samp_id IS NULL )
BEGIN
    :new.samp_id := samplecode_samp_id_seq.nextval;
END;
/

CREATE SEQUENCE sampledet_samp_det_id_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER sampledet_samp_det_id_trg BEFORE
    INSERT ON sampledet
    FOR EACH ROW
    WHEN ( new.samp_det_id IS NULL )
BEGIN
    :new.samp_det_id := sampledet_samp_det_id_seq.nextval;
END;
/

CREATE SEQUENCE spawndet_spawn_detail_id_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER spawndet_spawn_detail_id_trg BEFORE
    INSERT ON spawndet
    FOR EACH ROW
    WHEN ( new.spawn_detail_id IS NULL )
BEGIN
    :new.spawn_detail_id := spawndet_spawn_detail_id_seq.nextval;
END;
/

CREATE SEQUENCE spawndetcode_spawn_det_id_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER spawndetcode_spawn_det_id_trg BEFORE
    INSERT ON spawndetcode
    FOR EACH ROW
    WHEN ( new.spawn_det_id IS NULL )
BEGIN
    :new.spawn_det_id := spawndetcode_spawn_det_id_seq.nextval;
END;
/

CREATE SEQUENCE spawning_spawn_id_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER spawning_spawn_id_trg BEFORE
    INSERT ON spawning
    FOR EACH ROW
    WHEN ( new.spawn_id IS NULL )
BEGIN
    :new.spawn_id := spawning_spawn_id_seq.nextval;
END;
/

CREATE SEQUENCE speciescode_spec_id_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER speciescode_spec_id_trg BEFORE
    INSERT ON speciescode
    FOR EACH ROW
    WHEN ( new.spec_id IS NULL )
BEGIN
    :new.spec_id := speciescode_spec_id_seq.nextval;
END;
/

CREATE SEQUENCE stockcode_stock_id_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER stockcode_stock_id_trg BEFORE
    INSERT ON stockcode
    FOR EACH ROW
    WHEN ( new.stock_id IS NULL )
BEGIN
    :new.stock_id := stockcode_stock_id_seq.nextval;
END;
/

CREATE SEQUENCE subrivercode_subriver_id_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER subrivercode_subriver_id_trg BEFORE
    INSERT ON subrivercode
    FOR EACH ROW
    WHEN ( new.subriver_id IS NULL )
BEGIN
    :new.subriver_id := subrivercode_subriver_id_seq.nextval;
END;
/

CREATE SEQUENCE tank_tank_id_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER tank_tank_id_trg BEFORE
    INSERT ON tank
    FOR EACH ROW
    WHEN ( new.tank_id IS NULL )
BEGIN
    :new.tank_id := tank_tank_id_seq.nextval;
END;
/

CREATE SEQUENCE tankdet_tank_det_id_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER tankdet_tank_det_id_trg BEFORE
    INSERT ON tankdet
    FOR EACH ROW
    WHEN ( new.tank_det_id IS NULL )
BEGIN
    :new.tank_det_id := tankdet_tank_det_id_seq.nextval;
END;
/

CREATE SEQUENCE team_team_id_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER team_team_id_trg BEFORE
    INSERT ON team
    FOR EACH ROW
    WHEN ( new.team_id IS NULL )
BEGIN
    :new.team_id := team_team_id_seq.nextval;
END;
/

CREATE SEQUENCE tray_tray_id_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER tray_tray_id_trg BEFORE
    INSERT ON tray
    FOR EACH ROW
    WHEN ( new.tray_id IS NULL )
BEGIN
    :new.tray_id := tray_tray_id_seq.nextval;
END;
/

CREATE SEQUENCE traydet_tray_det_id_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER traydet_tray_det_id_trg BEFORE
    INSERT ON traydet
    FOR EACH ROW
    WHEN ( new.tray_det_id IS NULL )
BEGIN
    :new.tray_det_id := traydet_tray_det_id_seq.nextval;
END;
/

CREATE SEQUENCE trough_trough_id_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER trough_trough_id_trg BEFORE
    INSERT ON trough
    FOR EACH ROW
    WHEN ( new.trough_id IS NULL )
BEGIN
    :new.trough_id := trough_trough_id_seq.nextval;
END;
/

CREATE SEQUENCE troughdet_trough_det_id_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER troughdet_trough_det_id_trg BEFORE
    INSERT ON troughdet
    FOR EACH ROW
    WHEN ( new.trough_det_id IS NULL )
BEGIN
    :new.trough_det_id := troughdet_trough_det_id_seq.nextval;
END;
/

CREATE SEQUENCE unitcode_unit_id_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER unitcode_unit_id_trg BEFORE
    INSERT ON unitcode
    FOR EACH ROW
    WHEN ( new.unit_id IS NULL )
BEGIN
    :new.unit_id := unitcode_unit_id_seq.nextval;
END;
/



-- Oracle SQL Developer Data Modeler Summary Report: 
-- 
-- CREATE TABLE                            76
-- CREATE INDEX                           243
-- ALTER TABLE                            311
-- CREATE VIEW                              0
-- ALTER VIEW                               0
-- CREATE PACKAGE                           0
-- CREATE PACKAGE BODY                      0
-- CREATE PROCEDURE                         0
-- CREATE FUNCTION                          0
-- CREATE TRIGGER                          69
-- ALTER TRIGGER                            0
-- CREATE COLLECTION TYPE                   0
-- CREATE STRUCTURED TYPE                   0
-- CREATE STRUCTURED TYPE BODY              0
-- CREATE CLUSTER                           0
-- CREATE CONTEXT                           0
-- CREATE DATABASE                          0
-- CREATE DIMENSION                         0
-- CREATE DIRECTORY                         0
-- CREATE DISK GROUP                        0
-- CREATE ROLE                              0
-- CREATE ROLLBACK SEGMENT                  0
-- CREATE SEQUENCE                         69
-- CREATE MATERIALIZED VIEW                 0
-- CREATE MATERIALIZED VIEW LOG             0
-- CREATE SYNONYM                           0
-- CREATE TABLESPACE                        0
-- CREATE USER                              0
-- 
-- DROP TABLESPACE                          0
-- DROP DATABASE                            0
-- 
-- REDACTION POLICY                         0
-- 
-- ORDS DROP SCHEMA                         0
-- ORDS ENABLE SCHEMA                       0
-- ORDS ENABLE OBJECT                       0
-- 
-- ERRORS                                   0
-- WARNINGS                                 0
